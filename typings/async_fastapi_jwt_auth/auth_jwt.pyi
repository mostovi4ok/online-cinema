"""
This type stub file was generated by pyright.
"""

from collections.abc import Sequence
from datetime import timedelta
from typing import Any
from uuid import UUID

from async_fastapi_jwt_auth.auth_config import AuthConfig
from fastapi import Request, Response, WebSocket
from fastapi.security.http import HTTPBase

class AuthJWT(AuthConfig):
    def __init__(self, req: Request = ..., res: Response = ...) -> None:
        """
        Get jwt header from incoming request or get
        request and response object if jwt in the cookie

        :param req: all incoming request
        :param res: response from endpoint
        """

    async def create_access_token(
        self,
        subject: str | int | UUID,
        fresh: bool | None = ...,
        algorithm: str | None = ...,
        headers: dict[Any, Any] | None = ...,
        expires_time: timedelta | int | bool | None = ...,
        audience: str | Sequence[str] | None = ...,
        user_claims: dict[Any, Any] | None = ...,
    ) -> str:
        """
        Create a access token with 15 minutes for expired time (default),
        info for param and return check to function create token

        :return: hash token
        """

    async def create_refresh_token(
        self,
        subject: str | int,
        algorithm: str | None = ...,
        headers: dict[Any, Any] | None = ...,
        expires_time: timedelta | int | bool | None = ...,
        audience: str | Sequence[str] | None = ...,
        user_claims: dict[Any, Any] | None = ...,
    ) -> str:
        """
        Create a refresh token with 30 days for expired time (default),
        info for param and return check to function create token

        :return: hash token
        """

    async def set_access_cookies(
        self, encoded_access_token: str, response: Response | None = ..., max_age: int | None = ...
    ) -> None:
        """
        Configures the response to set access token in a cookie.
        this will also set the CSRF double submit values in a separate cookie

        :param encoded_access_token: The encoded access token to set in the cookies
        :param response: The FastAPI response object to set the access cookies in
        :param max_age: The max age of the cookie value should be the number of seconds (integer)
        """

    async def set_refresh_cookies(
        self, encoded_refresh_token: str, response: Response | None = ..., max_age: int | None = ...
    ) -> None:
        """
        Configures the response to set refresh token in a cookie.
        this will also set the CSRF double submit values in a separate cookie

        :param encoded_refresh_token: The encoded refresh token to set in the cookies
        :param response: The FastAPI response object to set the refresh cookies in
        :param max_age: The max age of the cookie value should be the number of seconds (integer)
        """

    async def unset_jwt_cookies(self, response: Response | None = ...) -> None:
        """
        Unset (delete) all jwt stored in a cookie

        :param response: The FastAPI response object to delete the JWT cookies in.
        """

    async def unset_access_cookies(self, response: Response | None = ...) -> None:
        """
        Remove access token and access CSRF double submit from the response cookies

        :param response: The FastAPI response object to delete the access cookies in.
        """

    async def unset_refresh_cookies(self, response: Response | None = ...) -> None:
        """
        Remove refresh token and refresh CSRF double submit from the response cookies

        :param response: The FastAPI response object to delete the refresh cookies in.
        """

    async def jwt_required(
        self,
        auth_from: str = ...,
        token: str | None = ...,
        websocket: WebSocket | None = ...,
        csrf_token: str | None = ...,
    ) -> None:
        """
        Only access token can access this function

        :param auth_from: for identity get token from HTTP or WebSocket
        :param token: the encoded JWT, it's required if the protected endpoint use WebSocket to
                      authorization and get token from Query Url or Path
        :param websocket: an instance of WebSocket, it's required if protected endpoint use a cookie to authorization
        :param csrf_token: the CSRF double submit token. since WebSocket cannot add specifying additional headers
                           its must be passing csrf_token manually and can achieve by Query Url or Path
        """

    async def jwt_optional(
        self,
        auth_from: str = ...,
        token: str | None = ...,
        websocket: WebSocket | None = ...,
        csrf_token: str | None = ...,
    ) -> None:
        """
        If an access token in present in the request you can get data from get_raw_jwt() or get_jwt_subject(),
        If no access token is present in the request, this endpoint will still be called, but
        get_raw_jwt() or get_jwt_subject() will return None

        :param auth_from: for identity get token from HTTP or WebSocket
        :param token: the encoded JWT, it's required if the protected endpoint use WebSocket to
                      authorization and get token from Query Url or Path
        :param websocket: an instance of WebSocket, it's required if protected endpoint use a cookie to authorization
        :param csrf_token: the CSRF double submit token. since WebSocket cannot add specifying additional headers
                           its must be passing csrf_token manually and can achieve by Query Url or Path
        """

    async def jwt_refresh_token_required(
        self,
        auth_from: str = ...,
        token: str | None = ...,
        websocket: WebSocket | None = ...,
        csrf_token: str | None = ...,
    ) -> None:
        """
        This function will ensure that the requester has a valid refresh token

        :param auth_from: for identity get token from HTTP or WebSocket
        :param token: the encoded JWT, it's required if the protected endpoint use WebSocket to
                      authorization and get token from Query Url or Path
        :param websocket: an instance of WebSocket, it's required if protected endpoint use a cookie to authorization
        :param csrf_token: the CSRF double submit token. since WebSocket cannot add specifying additional headers
                           its must be passing csrf_token manually and can achieve by Query Url or Path
        """

    async def fresh_jwt_required(
        self,
        auth_from: str = ...,
        token: str | None = ...,
        websocket: WebSocket | None = ...,
        csrf_token: str | None = ...,
    ) -> None:
        """
        This function will ensure that the requester has a valid access token and fresh token

        :param auth_from: for identity get token from HTTP or WebSocket
        :param token: the encoded JWT, it's required if the protected endpoint use WebSocket to
                      authorization and get token from Query Url or Path
        :param websocket: an instance of WebSocket, it's required if protected endpoint use a cookie to authorization
        :param csrf_token: the CSRF double submit token. since WebSocket cannot add specifying additional headers
                           its must be passing csrf_token manually and can achieve by Query Url or Path
        """

    async def get_raw_jwt(self, encoded_token: str | None = ...) -> dict[str, str | int | bool] | None:
        """
        this will return the python dictionary which has all of the claims of the JWT that is accessing the endpoint.
        If no JWT is currently present, return None instead

        :param encoded_token: The encoded JWT from parameter
        :return: claims of JWT
        """

    async def get_jti(self, encoded_token: str) -> str:
        """
        Returns the JTI (unique identifier) of an encoded JWT

        :param encoded_token: The encoded JWT from parameter
        :return: string of JTI
        """

    async def get_jwt_subject(self) -> str | int | UUID | None:
        """
        this will return the subject of the JWT that is accessing this endpoint.
        If no JWT is present, `None` is returned instead.

        :return: sub of JWT
        """

    async def get_unverified_jwt_headers(self, encoded_token: str | None = ...) -> dict:
        """
        Returns the Headers of an encoded JWT without verifying the actual signature of JWT

        :param encoded_token: The encoded JWT to get the Header from
        :return: JWT header parameters as a dictionary
        """

class AuthJWTBearer(HTTPBase):
    def __init__(
        self,
        *,
        bearerFormat: str | None = ...,
        scheme_name: str | None = ...,
        description: str | None = ...,
        auto_error: bool = ...,
    ) -> None: ...
    def __call__(self, req: Request = ..., res: Response = ...) -> AuthJWT: ...
