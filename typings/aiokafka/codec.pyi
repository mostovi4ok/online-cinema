"""
This type stub file was generated by pyright.
"""

from typing_extensions import Buffer

_XERIAL_V1_HEADER = ...
_XERIAL_V1_FORMAT = ...

def has_gzip() -> bool: ...
def has_snappy() -> bool: ...
def has_zstd() -> bool: ...
def has_lz4() -> bool: ...
def gzip_encode(payload: Buffer, compresslevel: int | None = ...) -> bytes: ...
def gzip_decode(payload: Buffer) -> bytes: ...
def snappy_encode(payload: Buffer, xerial_compatible: bool = ..., xerial_blocksize: int = ...) -> bytes:
    """Encodes the given data with snappy compression.

    If xerial_compatible is set then the stream is encoded in a fashion
    compatible with the xerial snappy library.

    The block size (xerial_blocksize) controls how frequent the blocking occurs
    32k is the default in the xerial library.

    The format winds up being:


        +-------------+------------+--------------+------------+--------------+
        |   Header    | Block1 len | Block1 data  | Blockn len | Blockn data  |
        +-------------+------------+--------------+------------+--------------+
        |  16 bytes   |  BE int32  | snappy bytes |  BE int32  | snappy bytes |
        +-------------+------------+--------------+------------+--------------+


    It is important to note that the blocksize is the amount of uncompressed
    data presented to snappy at each block, whereas the blocklen is the number
    of bytes that will be present in the stream; so the length will always be
    <= blocksize.

    """

def snappy_decode(payload: Buffer) -> bytes: ...
def lz4_encode(payload: Buffer, level: int = ...) -> bytes: ...
def lz4_decode(payload: Buffer) -> bytes: ...
def zstd_encode(payload: Buffer, level: int | None = ...) -> bytes: ...
def zstd_decode(payload: Buffer) -> bytes: ...
