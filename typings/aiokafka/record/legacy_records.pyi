"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterator
from dataclasses import dataclass
from typing import Any, Literal, Never, final

from aiokafka.util import NO_EXTENSIONS

from ._protocols import (
    LegacyRecordBatchBuilderProtocol,
    LegacyRecordBatchProtocol,
    LegacyRecordMetadataProtocol,
    LegacyRecordProtocol,
)
from ._types import CodecGzipT, CodecLz4T, CodecMaskT, CodecSnappyT, LegacyCompressionTypeT

NoneType = ...

class LegacyRecordBase:
    __slots__ = ...
    HEADER_STRUCT_V0 = ...
    HEADER_STRUCT_V1 = ...
    CRC_OFFSET = ...
    MAGIC_OFFSET = ...
    RECORD_OVERHEAD_V0 = ...
    RECORD_OVERHEAD_V1 = ...
    RECORD_OVERHEAD = ...
    KEY_OFFSET_V0 = ...
    KEY_OFFSET_V1 = ...
    VALUE_LENGTH = ...
    CODEC_MASK: CodecMaskT = ...
    CODEC_GZIP: CodecGzipT = ...
    CODEC_SNAPPY: CodecSnappyT = ...
    CODEC_LZ4: CodecLz4T = ...
    TIMESTAMP_TYPE_MASK = ...
    LOG_APPEND_TIME = ...
    CREATE_TIME = ...

@final
class _LegacyRecordBatchPy(LegacyRecordBase, LegacyRecordBatchProtocol):
    is_control_batch: bool = ...
    is_transactional: bool = ...
    producer_id: int | None = ...
    def __init__(self, buffer: bytes | bytearray | memoryview, magic: int) -> None: ...
    @property
    def next_offset(self) -> int: ...
    def validate_crc(self) -> bool: ...
    def __iter__(self) -> Iterator[_LegacyRecordPy]: ...

@final
@dataclass(frozen=True)
class _LegacyRecordPy(LegacyRecordProtocol):
    __slots__ = ...
    offset: int
    timestamp: int | None
    timestamp_type: Literal[0, 1] | None
    key: bytes | None
    value: bytes | None
    crc: int
    @property
    def headers(self) -> list[Never]: ...
    @property
    def checksum(self) -> int: ...

@final
class _LegacyRecordBatchBuilderPy(LegacyRecordBase, LegacyRecordBatchBuilderProtocol):
    _buffer: bytearray | None = ...
    def __init__(self, magic: Literal[0, 1], compression_type: LegacyCompressionTypeT, batch_size: int) -> None: ...
    def append(
        self, offset: int, timestamp: int | None, key: bytes | None, value: bytes | None, headers: Any = ...
    ) -> _LegacyRecordMetadataPy | None:
        """Append message to batch."""

    def build(self) -> bytearray:
        """Compress batch to be ready for send"""

    def size(self) -> int:
        """Return current size of data written to buffer"""

    def size_in_bytes(self, offset: Any, timestamp: Any, key: bytes | None, value: bytes | None) -> int:
        """Actual size of message to add"""

    @classmethod
    def record_overhead(cls, magic: int) -> int: ...

@final
class _LegacyRecordMetadataPy(LegacyRecordMetadataProtocol):
    __slots__ = ...
    def __init__(self, offset: int, crc: int, size: int, timestamp: int) -> None: ...
    @property
    def offset(self) -> int: ...
    @property
    def crc(self) -> int: ...
    @property
    def size(self) -> int: ...
    @property
    def timestamp(self) -> int: ...

LegacyRecordBatchBuilder: type[LegacyRecordBatchBuilderProtocol]
LegacyRecordMetadata: type[LegacyRecordMetadataProtocol]
LegacyRecordBatch: type[LegacyRecordBatchProtocol]
LegacyRecord: type[LegacyRecordProtocol]
if NO_EXTENSIONS:
    LegacyRecordBatchBuilder = ...
    LegacyRecordMetadata = ...
    LegacyRecordBatch = ...
    LegacyRecord = ...
else:
    LegacyRecordBatchBuilder = ...
    LegacyRecordMetadata = ...
    LegacyRecordBatch = ...
    LegacyRecord = ...
