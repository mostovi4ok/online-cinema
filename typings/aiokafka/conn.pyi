"""
This type stub file was generated by pyright.
"""

import asyncio

__all__ = ["AIOKafkaConnection", "create_conn"]
log = ...
DEFAULT_KAFKA_PORT = ...
READER_LIMIT = ...
SASL_QOP_AUTH = ...

class CloseReason:
    CONNECTION_BROKEN = ...
    CONNECTION_TIMEOUT = ...
    OUT_OF_SYNC = ...
    IDLE_DROP = ...
    SHUTDOWN = ...
    AUTH_FAILURE = ...

class VersionInfo:
    def __init__(self, versions) -> None: ...
    def pick_best(self, request_versions): ...

async def create_conn(
    host,
    port,
    *,
    client_id=...,
    request_timeout_ms=...,
    api_version=...,
    ssl_context=...,
    security_protocol=...,
    max_idle_ms=...,
    on_close=...,
    sasl_mechanism=...,
    sasl_plain_username=...,
    sasl_plain_password=...,
    sasl_kerberos_service_name=...,
    sasl_kerberos_domain_name=...,
    sasl_oauth_token_provider=...,
    version_hint=...,
):  # -> AIOKafkaConnection:
    ...

class AIOKafkaProtocol(asyncio.StreamReaderProtocol):
    def __init__(self, closed_fut, *args, loop, **kw) -> None: ...
    def connection_lost(self, exc):  # -> None:
        ...

class AIOKafkaConnection:
    """Class for manage connection to Kafka node"""

    _reader = ...
    _source_traceback = ...
    def __init__(
        self,
        host,
        port,
        *,
        client_id=...,
        request_timeout_ms=...,
        api_version=...,
        ssl_context=...,
        security_protocol=...,
        max_idle_ms=...,
        on_close=...,
        sasl_mechanism=...,
        sasl_plain_password=...,
        sasl_plain_username=...,
        sasl_kerberos_service_name=...,
        sasl_kerberos_domain_name=...,
        sasl_oauth_token_provider=...,
        version_hint=...,
    ) -> None: ...
    def __del__(self, _warnings=...):  # -> None:
        ...
    async def connect(self):  # -> tuple[StreamReader, StreamWriter]:
        ...
    def authenticator_plain(self):  # -> SaslPlainAuthenticator:
        ...
    def authenticator_gssapi(self):  # -> SaslGSSAPIAuthenticator:
        ...
    def authenticator_scram(self):  # -> ScramAuthenticator:
        ...
    def authenticator_oauth(self):  # -> OAuthAuthenticator:
        ...
    @property
    def sasl_principal(self):  # -> str:
        ...
    def __repr__(self):  # -> str:
        ...
    @property
    def host(self):  # -> Any:
        ...
    @property
    def port(self):  # -> Any:
        ...
    def send(self, request, expect_response=...):  # -> Coroutine[Any, Any, None] | Coroutine[Any, Any, Any]:
        ...
    def connected(self):  # -> bool:
        ...
    def close(self, reason=..., exc=...):  # -> Future[Any] | None:
        ...

class BaseSaslAuthenticator:
    def step(self, payload): ...

class SaslPlainAuthenticator(BaseSaslAuthenticator):
    def __init__(self, *, loop, sasl_plain_password, sasl_plain_username) -> None: ...
    def authenticator_plain(self):  # -> Generator[tuple[bytes, Literal[True]], Any, None]:
        """Automaton to authenticate with SASL tokens"""

class SaslGSSAPIAuthenticator(BaseSaslAuthenticator):
    def __init__(self, *, loop, principal) -> None: ...
    def authenticator_gssapi(
        self,
    ):  # -> Generator[tuple[Any | Literal[b""], Literal[True]] | tuple[Any, Literal[False]], Any, None]:
        ...

class ScramAuthenticator(BaseSaslAuthenticator):
    MECHANISMS = ...
    def __init__(self, *, loop, sasl_plain_password, sasl_plain_username, sasl_mechanism) -> None: ...
    def first_message(self):  # -> str:
        ...
    def process_server_first_message(self, server_first):  # -> None:
        ...
    def final_message(self):  # -> str:
        ...
    def process_server_final_message(self, server_final):  # -> None:
        ...
    def authenticator_scram(self):  # -> Generator[tuple[bytes, Literal[True]], Any, None]:
        ...
    def hmac(self, key, msg):  # -> bytes:
        ...
    def create_salted_password(self, salt, iterations):  # -> None:
        ...

class OAuthAuthenticator(BaseSaslAuthenticator):
    def __init__(self, *, sasl_oauth_token_provider) -> None: ...
    async def step(self, payload):  # -> tuple[bytes, Literal[True]] | None:
        ...

def get_ip_port_afi(
    host_and_port_str,
):  # -> tuple[Any, int, Literal[AddressFamily.AF_INET6]] | tuple[Any, Literal[9092], Literal[AddressFamily.AF_INET6, AddressFamily.AF_INET, AddressFamily.AF_UNSPEC]] | tuple[Any, Literal[9092], Literal[AddressFamily.AF_INET6]] | tuple[Any, int, Literal[AddressFamily.AF_INET6, AddressFamily.AF_INET, AddressFamily.AF_UNSPEC]]:
    """
    Parse the IP and port from a string in the format of:

        * host_or_ip          <- Can be either IPv4 address literal or hostname/fqdn
        * host_or_ipv4:port   <- Can be either IPv4 address literal or hostname/fqdn
        * [host_or_ip]        <- IPv6 address literal
        * [host_or_ip]:port.  <- IPv6 address literal

    .. note:: IPv6 address literals with ports *must* be enclosed in brackets

    .. note:: If the port is not specified, default will be returned.

    :return: tuple (host, port, afi), afi will be socket.AF_INET or
    socket.AF_INET6 or socket.AF_UNSPEC
    """

def collect_hosts(hosts, randomize=...):  # -> list[Any]:
    """
    Collects a comma-separated set of hosts (host:port) and optionally
    randomize the returned list.
    """
