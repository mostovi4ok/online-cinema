"""
This type stub file was generated by pyright.
"""

__all__ = ["AIOKafkaClient"]
log = ...

class ConnectionGroup:
    DEFAULT = ...
    COORDINATION = ...

class CoordinationType:
    GROUP = ...
    TRANSACTION = ...

class AIOKafkaClient:
    """Initialize an asynchronous kafka client

    Keyword Arguments:
        bootstrap_servers: 'host[:port]' string (or list of 'host[:port]'
            strings) that the consumer should contact to bootstrap initial
            cluster metadata. This does not have to be the full node list.
            It just needs to have at least one broker that will respond to
            Metadata API Request. Default port is 9092. If no servers are
            specified, will default to localhost:9092.
        client_id (str): a name for this client. This string is passed in
            each request to servers and can be used to identify specific
            server-side log entries that correspond to this client. Also
            submitted to GroupCoordinator for logging with respect to
            consumer group administration. Default: 'aiokafka-{ver}'
        request_timeout_ms (int): Client request timeout in milliseconds.
            Default: 40000.
        metadata_max_age_ms (int): The period of time in milliseconds after
            which we force a refresh of metadata even if we haven't seen
            any partition leadership changes to proactively discover any
            new brokers or partitions. Default: 300000
        retry_backoff_ms (int): Milliseconds to backoff when retrying on
            errors. Default: 100.
        api_version (str): specify which kafka API version to use.
            AIOKafka supports Kafka API versions >=0.9 only.
            If set to 'auto', will attempt to infer the broker version by
            probing various APIs. Default: auto
        security_protocol (str): Protocol used to communicate with brokers.
            Valid values are: PLAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL.
            Default: PLAINTEXT.
        ssl_context (ssl.SSLContext): pre-configured SSLContext for wrapping
            socket connections. For more information see :ref:`ssl_auth`.
            Default: None.
        connections_max_idle_ms (int): Close idle connections after the number
            of milliseconds specified by this config. Specifying `None` will
            disable idle checks. Default: 540000 (9 minutes).

    """

    def __init__(
        self,
        *,
        loop=...,
        bootstrap_servers=...,
        client_id=...,
        metadata_max_age_ms=...,
        request_timeout_ms=...,
        retry_backoff_ms=...,
        ssl_context=...,
        security_protocol=...,
        api_version=...,
        connections_max_idle_ms=...,
        sasl_mechanism=...,
        sasl_plain_username=...,
        sasl_plain_password=...,
        sasl_kerberos_service_name=...,
        sasl_kerberos_domain_name=...,
        sasl_oauth_token_provider=...,
    ) -> None: ...
    def __repr__(self):  # -> str:
        ...
    @property
    def api_version(self):  # -> Tuple[int, int, int] | tuple[Any, ...] | tuple[Literal[0], Literal[9], Literal[0]]:
        ...
    @property
    def hosts(self):  # -> list[Any]:
        ...
    async def close(self):  # -> None:
        ...
    async def bootstrap(self):  # -> None:
        """Try to to bootstrap initial cluster metadata"""

    def get_random_node(self):  # -> None:
        """Choice random node from known cluster brokers

        Returns:
            nodeId - identifier of broker

        """

    def force_metadata_update(self):  # -> Future[Any]:
        """Update cluster metadata

        Returns:
            True/False - metadata updated or not

        """

    async def fetch_all_metadata(self):  # -> ClusterMetadata:
        ...
    def add_topic(self, topic):  # -> Future[Any]:
        """Add a topic to the list of topics tracked via metadata.

        Arguments:
            topic (str): topic to track

        """

    def set_topics(self, topics):  # -> Future[Any]:
        """Set specific topics to track for metadata.

        Arguments:
            topics (list of str): topics to track

        """

    async def ready(self, node_id, *, group=...):  # -> bool:
        ...
    async def send(self, node_id, request, *, group=...):
        """Send a request to a specific node.

        Arguments:
            node_id (int): destination node
            request (Struct): request object (not-encoded)

        Raises:
            aiokafka.errors.RequestTimedOutError
            aiokafka.errors.NodeNotReadyError
            aiokafka.errors.KafkaConnectionError
            aiokafka.errors.CorrelationIdError

        Returns:
            Future: resolves to Response struct

        """

    async def check_version(
        self, node_id=...
    ):  # -> tuple[int, int, int] | tuple[Literal[0], Literal[10], Literal[0]] | tuple[int, int]:
        """Attempt to guess the broker version"""

    async def coordinator_lookup(self, coordinator_type, coordinator_key):
        """Lookup which node in the cluster is the coordinator for a certain
        role (Transaction coordinator or Group coordinator atm.)
        NOTE: Client keeps track of all coordination nodes separately, as they
        all have different sockets and ids.
        """
