"""
This type stub file was generated by pyright.
"""

from collections import OrderedDict as OrderedDictType
from dataclasses import dataclass
from enum import StrEnum
from typing import TYPE_CHECKING, Any, Generic, NewType, TypeVar

from beanie.odm.documents import DocType
from beanie.odm.utils.pydantic import IS_PYDANTIC_V2
from bson import DBRef, ObjectId
from pydantic import BaseModel, GetCoreSchemaHandler, GetJsonSchemaHandler
from pydantic.fields import ModelField
from pydantic.json_schema import JsonSchemaValue
from pydantic_core import CoreSchema, core_schema
from pydantic_core.core_schema import ValidationInfo
from pymongo import IndexModel

if IS_PYDANTIC_V2: ...
else: ...
if TYPE_CHECKING: ...
if IS_PYDANTIC_V2:
    plain_validator = ...
else:
    def plain_validator(v): ...

@dataclass(frozen=True)
class IndexedAnnotation:
    _indexed: tuple[int, dict[str, Any]]

def Indexed(typ: Any = None, index_type: int = ..., **kwargs: Any) -> IndexedAnnotation | type[NewType]:
    """
    If `typ` is defined, returns a subclass of `typ` with an extra attribute
    `_indexed` as a tuple:
    - Index 0: `index_type` such as `pymongo.ASCENDING`
    - Index 1: `kwargs` passed to `IndexModel`
    When instantiated the type of the result will actually be `typ`.

    When `typ` is not defined, returns an `IndexedAnnotation` instance, to be
    used as metadata in `Annotated` fields.

    Example:
    ```py
    # Both fields would have the same behavior
    class MyModel(BaseModel):
        field1: Indexed(str, unique=True)
        field2: Annotated[str, Indexed(unique=True)]
    ```

    """
    class NewType(typ): ...

class PydanticObjectId(ObjectId):
    """
    Object Id field. Compatible with Pydantic.
    """

    @classmethod
    def __get_validators__(cls):  # -> Generator[Callable[..., PydanticObjectId], Any, None]:
        ...

    if IS_PYDANTIC_V2:
        @classmethod
        def validate(cls, v, _: ValidationInfo):  # -> PydanticObjectId:
            ...
        @classmethod
        def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema: ...
        @classmethod
        def __get_pydantic_json_schema__(
            cls, schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler
        ) -> JsonSchemaValue: ...

    else:
        @classmethod
        def validate(cls, v):  # -> PydanticObjectId:
            ...
        @classmethod
        def __modify_schema__(cls, field_schema):  # -> None:
            ...

if not IS_PYDANTIC_V2: ...
BeanieObjectId = PydanticObjectId

class ExpressionField(str):
    def __getitem__(self, item):  # -> ExpressionField:
        """
        Get sub field

        :param item: name of the subfield
        :return: ExpressionField
        """

    def __getattr__(self, item):  # -> ExpressionField:
        """
        Get sub field

        :param item: name of the subfield
        :return: ExpressionField
        """

    def __hash__(self) -> int: ...
    def __eq__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __pos__(self):  # -> tuple[Self, Literal[SortDirection.ASCENDING]]:
        ...
    def __neg__(self):  # -> tuple[Self, Literal[SortDirection.DESCENDING]]:
        ...
    def __copy__(self):  # -> Self:
        ...
    def __deepcopy__(self, memo):  # -> Self:
        ...

class DeleteRules(StrEnum):
    DO_NOTHING = ...
    DELETE_LINKS = ...

class WriteRules(StrEnum):
    DO_NOTHING = ...
    WRITE = ...

class LinkTypes(StrEnum):
    DIRECT = ...
    OPTIONAL_DIRECT = ...
    LIST = ...
    OPTIONAL_LIST = ...
    BACK_DIRECT = ...
    BACK_LIST = ...
    OPTIONAL_BACK_DIRECT = ...
    OPTIONAL_BACK_LIST = ...

class LinkInfo(BaseModel):
    field_name: str
    lookup_field_name: str
    document_class: type[BaseModel]
    link_type: LinkTypes
    nested_links: dict | None = ...
    is_fetchable: bool = ...

T = TypeVar("T")

class Link(Generic[T]):
    def __init__(self, ref: DBRef, document_class: type[T]) -> None: ...
    async def fetch(self, fetch_links: bool = ...) -> T | Link: ...
    @classmethod
    async def fetch_one(cls, link: Link):  # -> Link[Any]:
        ...
    @classmethod
    async def fetch_list(cls, links: list[Link | DocType], fetch_links: bool = ...):  # -> list[Any]:
        """
        Fetch list that contains links and documents
        :param links:
        :param fetch_links:
        :return:
        """

    @staticmethod
    def repack_links(links: list[Link | DocType]) -> OrderedDictType[Any, Any]: ...
    @classmethod
    async def fetch_many(cls, links: list[Link]):  # -> list[Any]:
        ...

    if IS_PYDANTIC_V2:
        @staticmethod
        def serialize(value: Link | BaseModel):  # -> dict[str, str] | dict[str, Any]:
            ...
        @classmethod
        def build_validation(cls, handler, source_type):  # -> Callable[..., Self | Link[Any] | BaseModel]:
            ...
        @classmethod
        def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema: ...

    else:
        @classmethod
        def __get_validators__(cls):  # -> Generator[Callable[..., Self | Link[Any] | BaseModel], Any, None]:
            ...
        @classmethod
        def validate(cls, v: DBRef | T, field: ModelField):  # -> Self | Link[Any] | BaseModel:
            ...

    def to_ref(self):  # -> DBRef:
        ...
    def to_dict(self):  # -> dict[str, str]:
        ...

if not IS_PYDANTIC_V2: ...

class BackLink(Generic[T]):
    """Back reference to a document"""

    def __init__(self, document_class: type[T]) -> None: ...

    if IS_PYDANTIC_V2:
        @classmethod
        def build_validation(cls, handler, source_type):  # -> Callable[..., BaseModel | Self]:
            ...
        @classmethod
        def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema: ...

    else:
        @classmethod
        def __get_validators__(cls):  # -> Generator[Callable[..., BaseModel | Self], Any, None]:
            ...
        @classmethod
        def validate(cls, v: DBRef | T, field: ModelField):  # -> BaseModel | Self:
            ...

    def to_dict(self):  # -> dict[str, Any]:
        ...

if not IS_PYDANTIC_V2: ...

class IndexModelField:
    def __init__(self, index: IndexModel) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __repr__(self):  # -> str:
        ...
    @staticmethod
    def list_difference(left: list[IndexModelField], right: list[IndexModelField]):  # -> list[Any]:
        ...
    @staticmethod
    def list_to_index_model(left: list[IndexModelField]):  # -> list[IndexModel]:
        ...
    @classmethod
    def from_motor_index_information(cls, index_info: dict):  # -> list[Any]:
        ...
    def same_fields(self, other: IndexModelField):  # -> bool:
        ...
    @staticmethod
    def find_index_with_the_same_fields(
        indexes: list[IndexModelField], index: IndexModelField
    ):  # -> IndexModelField | None:
        ...
    @staticmethod
    def merge_indexes(left: list[IndexModelField], right: list[IndexModelField]):  # -> list[IndexModelField]:
        ...

    if IS_PYDANTIC_V2:
        @classmethod
        def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema: ...

    else:
        @classmethod
        def __get_validators__(cls):  # -> Generator[Callable[..., IndexModelField], Any, None]:
            ...
        @classmethod
        def validate(cls, v):  # -> IndexModelField:
            ...
