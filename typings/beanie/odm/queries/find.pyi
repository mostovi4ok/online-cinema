"""
This type stub file was generated by pyright.
"""

from collections.abc import Coroutine, Generator, Mapping
from typing import TYPE_CHECKING, Any, Generic, TypeVar, overload

from beanie.odm.bulk import BulkWriter
from beanie.odm.documents import DocType
from beanie.odm.enums import SortDirection
from beanie.odm.interfaces.aggregation_methods import AggregateMethods
from beanie.odm.interfaces.clone import CloneInterface
from beanie.odm.interfaces.session import SessionMethods
from beanie.odm.interfaces.update import UpdateMethods
from beanie.odm.queries.aggregation import AggregationQuery
from beanie.odm.queries.cursor import BaseCursorQuery
from beanie.odm.queries.delete import DeleteMany, DeleteOne
from beanie.odm.queries.update import UpdateMany, UpdateOne, UpdateQuery, UpdateResponse
from motor.motor_asyncio import AsyncIOMotorClientSession
from pydantic import BaseModel
from pymongo.results import UpdateResult

if TYPE_CHECKING: ...
FindQueryProjectionType = TypeVar("FindQueryProjectionType", bound=BaseModel)
FindQueryResultType = TypeVar("FindQueryResultType", bound=BaseModel)

class FindQuery(UpdateMethods, SessionMethods, CloneInterface, Generic[FindQueryResultType]):
    """
    Find Query base class
    """

    UpdateQueryType: type[UpdateQuery | UpdateMany | UpdateOne] = ...
    DeleteQueryType: type[DeleteOne | DeleteMany] = ...
    AggregationQueryType = AggregationQuery
    def __init__(self, document_model: type[DocType]) -> None: ...
    def prepare_find_expressions(self):  # -> None:
        ...
    def get_filter_query(self) -> Mapping[str, Any]:
        """

        Returns: MongoDB filter query

        """

    def delete(
        self,
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        **pymongo_kwargs: Any,
    ) -> DeleteOne | DeleteMany:
        """
        Provide search criteria to the Delete query

        :param session: Optional[AsyncIOMotorClientSession]
        :return: Union[DeleteOne, DeleteMany]
        """

    def project(self, projection_model):  # -> Self:
        """
        Apply projection parameter
        :param projection_model: Optional[Type[BaseModel]] - projection model
        :return: self
        """

    def get_projection_model(self) -> type[FindQueryResultType]: ...
    async def count(self) -> int:
        """
        Number of found documents
        :return: int
        """

    async def exists(self) -> bool:
        """
        If find query will return anything

        :return: bool
        """

class FindMany(FindQuery[FindQueryResultType], BaseCursorQuery[FindQueryResultType], AggregateMethods):
    """
    Find Many query class
    """

    UpdateQueryType = UpdateMany
    DeleteQueryType = DeleteMany
    def __init__(self, document_model: type[DocType]) -> None: ...
    @overload
    def find_many(
        self: FindMany[FindQueryResultType],
        *args: Mapping[str, Any] | bool,
        projection_model: None = ...,
        skip: int | None = ...,
        limit: int | None = ...,
        sort: None | str | list[tuple[str, SortDirection]] = ...,
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        fetch_links: bool = ...,
        lazy_parse: bool = ...,
        nesting_depth: int | None = ...,
        nesting_depths_per_field: dict[str, int] | None = ...,
        **pymongo_kwargs: Any,
    ) -> FindMany[FindQueryResultType]: ...
    @overload
    def find_many(
        self: FindMany[FindQueryResultType],
        *args: Mapping[str, Any] | bool,
        projection_model: type[FindQueryProjectionType] | None = ...,
        skip: int | None = ...,
        limit: int | None = ...,
        sort: None | str | list[tuple[str, SortDirection]] = ...,
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        fetch_links: bool = ...,
        lazy_parse: bool = ...,
        nesting_depth: int | None = ...,
        nesting_depths_per_field: dict[str, int] | None = ...,
        **pymongo_kwargs: Any,
    ) -> FindMany[FindQueryProjectionType]: ...
    def find_many(
        self: FindMany[FindQueryResultType],
        *args: Mapping[str, Any] | bool,
        projection_model: type[FindQueryProjectionType] | None = ...,
        skip: int | None = ...,
        limit: int | None = ...,
        sort: None | str | list[tuple[str, SortDirection]] = ...,
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        fetch_links: bool = ...,
        lazy_parse: bool = ...,
        nesting_depth: int | None = ...,
        nesting_depths_per_field: dict[str, int] | None = ...,
        **pymongo_kwargs: Any,
    ) -> FindMany[FindQueryResultType] | FindMany[FindQueryProjectionType]:
        """
        Find many documents by criteria

        :param args: *Mapping[str, Any] - search criteria
        :param skip: Optional[int] - The number of documents to omit.
        :param limit: Optional[int] - The maximum number of results to return.
        :param sort: Union[None, str, List[Tuple[str, SortDirection]]] - A key
        or a list of (key, direction) pairs specifying the sort order
        for this query.
        :param projection_model: Optional[Type[BaseModel]] - projection model
        :param session: Optional[AsyncIOMotorClientSession] - motor session
        :param ignore_cache: bool
        :param **pymongo_kwargs: pymongo native parameters for find operation (if Document class contains links, this parameter must fit the respective parameter of the aggregate MongoDB function)
        :return: FindMany - query instance
        """

    @overload
    def project(self: FindMany, projection_model: None) -> FindMany[FindQueryResultType]: ...
    @overload
    def project(
        self: FindMany, projection_model: type[FindQueryProjectionType]
    ) -> FindMany[FindQueryProjectionType]: ...
    def project(
        self: FindMany, projection_model: type[FindQueryProjectionType] | None
    ) -> FindMany[FindQueryResultType] | FindMany[FindQueryProjectionType]:
        """
        Apply projection parameter

        :param projection_model: Optional[Type[BaseModel]] - projection model
        :return: self
        """

    @overload
    def find(
        self: FindMany[FindQueryResultType],
        *args: Mapping[str, Any] | bool,
        projection_model: None = ...,
        skip: int | None = ...,
        limit: int | None = ...,
        sort: None | str | list[tuple[str, SortDirection]] = ...,
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        fetch_links: bool = ...,
        lazy_parse: bool = ...,
        nesting_depth: int | None = ...,
        nesting_depths_per_field: dict[str, int] | None = ...,
        **pymongo_kwargs,
    ) -> FindMany[FindQueryResultType]: ...
    @overload
    def find(
        self: FindMany[FindQueryResultType],
        *args: Mapping[str, Any] | bool,
        projection_model: type[FindQueryProjectionType] | None = ...,
        skip: int | None = ...,
        limit: int | None = ...,
        sort: None | str | list[tuple[str, SortDirection]] = ...,
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        fetch_links: bool = ...,
        lazy_parse: bool = ...,
        nesting_depth: int | None = ...,
        nesting_depths_per_field: dict[str, int] | None = ...,
        **pymongo_kwargs,
    ) -> FindMany[FindQueryProjectionType]: ...
    def find(
        self: FindMany[FindQueryResultType],
        *args: Mapping[str, Any] | bool,
        projection_model: type[FindQueryProjectionType] | None = ...,
        skip: int | None = ...,
        limit: int | None = ...,
        sort: None | str | list[tuple[str, SortDirection]] = ...,
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        fetch_links: bool = ...,
        lazy_parse: bool = ...,
        nesting_depth: int | None = ...,
        nesting_depths_per_field: dict[str, int] | None = ...,
        **pymongo_kwargs,
    ) -> FindMany[FindQueryResultType] | FindMany[FindQueryProjectionType]:
        """
        The same as `find_many(...)`
        """

    def sort(
        self, *args: str | tuple[str, SortDirection] | list[tuple[str, SortDirection]] | None
    ) -> FindMany[FindQueryResultType]:
        """
        Add sort parameters
        :param args: Union[str, Tuple[str, SortDirection],
        List[Tuple[str, SortDirection]]] - A key or a tuple (key, direction)
        or a list of (key, direction) pairs specifying
        the sort order for this query.
        :return: self
        """

    def skip(self, n: int | None) -> FindMany[FindQueryResultType]:
        """
        Set skip parameter
        :param n: int
        :return: self
        """

    def limit(self, n: int | None) -> FindMany[FindQueryResultType]:
        """
        Set limit parameter
        :param n: int
        :return:
        """

    def update(
        self,
        *args: Mapping[str, Any],
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        **pymongo_kwargs,
    ):  # -> UpdateQuery:
        """
        Create Update with modifications query
        and provide search criteria there

        :param args: *Mapping[str,Any] - the modifications to apply.
        :param session: Optional[AsyncIOMotorClientSession]
        :param bulk_writer: Optional[BulkWriter]
        :return: UpdateMany query
        """

    def upsert(
        self,
        *args: Mapping[str, Any],
        on_insert: DocType,
        session: AsyncIOMotorClientSession | None = ...,
        **pymongo_kwargs,
    ):  # -> UpdateQuery:
        """
        Create Update with modifications query
        and provide search criteria there

        :param args: *Mapping[str,Any] - the modifications to apply.
        :param on_insert: DocType - document to insert if there is no matched
        document in the collection
        :param session: Optional[AsyncIOMotorClientSession]
        :return: UpdateMany query
        """

    def update_many(
        self,
        *args: Mapping[str, Any],
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        **pymongo_kwargs,
    ) -> UpdateMany:
        """
        Provide search criteria to the
        [UpdateMany](query.md#updatemany) query

        :param args: *Mapping[str,Any] - the modifications to apply.
        :param session: Optional[AsyncIOMotorClientSession]
        :return: [UpdateMany](query.md#updatemany) query
        """

    def delete_many(
        self,
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        **pymongo_kwargs,
    ) -> DeleteMany:
        """
        Provide search criteria to the [DeleteMany](query.md#deletemany) query

        :param session:
        :return: [DeleteMany](query.md#deletemany) query
        """

    @overload
    def aggregate(
        self,
        aggregation_pipeline: list[Any],
        projection_model: None = ...,
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        **pymongo_kwargs,
    ) -> AggregationQuery[dict[str, Any]]: ...
    @overload
    def aggregate(
        self,
        aggregation_pipeline: list[Any],
        projection_model: type[FindQueryProjectionType],
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        **pymongo_kwargs,
    ) -> AggregationQuery[FindQueryProjectionType]: ...
    def aggregate(
        self,
        aggregation_pipeline: list[Any],
        projection_model: type[FindQueryProjectionType] | None = ...,
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        **pymongo_kwargs,
    ) -> AggregationQuery[dict[str, Any]] | AggregationQuery[FindQueryProjectionType]:
        """
        Provide search criteria to the [AggregationQuery](query.md#aggregationquery)

        :param aggregation_pipeline: list - aggregation pipeline. MongoDB doc:
        <https://docs.mongodb.com/manual/core/aggregation-pipeline/>
        :param projection_model: Type[BaseModel] - Projection Model
        :param session: Optional[AsyncIOMotorClientSession] - PyMongo session
        :param ignore_cache: bool
        :return:[AggregationQuery](query.md#aggregationquery)
        """

    def build_aggregation_pipeline(self, *extra_stages):  # -> List[Dict[str, Any]]:
        ...
    @property
    def motor_cursor(self):  # -> AsyncIOMotorCommandCursor[Any] | AsyncIOMotorCursor[Any]:
        ...
    async def first_or_none(self) -> FindQueryResultType | None:
        """
        Returns the first found element or None if no elements were found
        """

    async def count(self) -> int:
        """
        Number of found documents
        :return: int
        """

class FindOne(FindQuery[FindQueryResultType]):
    """
    Find One query class
    """

    UpdateQueryType = UpdateOne
    DeleteQueryType = DeleteOne
    @overload
    def project(self: FindOne[FindQueryResultType], projection_model: None = ...) -> FindOne[FindQueryResultType]: ...
    @overload
    def project(
        self: FindOne[FindQueryResultType], projection_model: type[FindQueryProjectionType]
    ) -> FindOne[FindQueryProjectionType]: ...
    def project(
        self: FindOne[FindQueryResultType], projection_model: type[FindQueryProjectionType] | None = ...
    ) -> FindOne[FindQueryResultType] | FindOne[FindQueryProjectionType]:
        """
        Apply projection parameter
        :param projection_model: Optional[Type[BaseModel]] - projection model
        :return: self
        """

    @overload
    def find_one(
        self: FindOne[FindQueryResultType],
        *args: Mapping[str, Any] | bool,
        projection_model: None = ...,
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        fetch_links: bool = ...,
        nesting_depth: int | None = ...,
        nesting_depths_per_field: dict[str, int] | None = ...,
        **pymongo_kwargs: Any,
    ) -> FindOne[FindQueryResultType]: ...
    @overload
    def find_one(
        self: FindOne[FindQueryResultType],
        *args: Mapping[str, Any] | bool,
        projection_model: type[FindQueryProjectionType],
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        fetch_links: bool = ...,
        nesting_depth: int | None = ...,
        nesting_depths_per_field: dict[str, int] | None = ...,
        **pymongo_kwargs: Any,
    ) -> FindOne[FindQueryProjectionType]: ...
    def find_one(
        self: FindOne[FindQueryResultType],
        *args: Mapping[str, Any] | bool,
        projection_model: type[FindQueryProjectionType] | None = ...,
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        fetch_links: bool = ...,
        nesting_depth: int | None = ...,
        nesting_depths_per_field: dict[str, int] | None = ...,
        **pymongo_kwargs: Any,
    ) -> FindOne[FindQueryResultType] | FindOne[FindQueryProjectionType]:
        """
        Find one document by criteria

        :param args: *Mapping[str, Any] - search criteria
        :param projection_model: Optional[Type[BaseModel]] - projection model
        :param session: Optional[AsyncIOMotorClientSession] - motor session
        :param ignore_cache: bool
        :param **pymongo_kwargs: pymongo native parameters for find operation (if Document class contains links, this parameter must fit the respective parameter of the aggregate MongoDB function)
        :return: FindOne - query instance
        """

    def update(
        self,
        *args: Mapping[str, Any],
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        response_type: UpdateResponse | None = ...,
        **pymongo_kwargs,
    ):  # -> UpdateQuery:
        """
        Create Update with modifications query
        and provide search criteria there

        :param args: *Mapping[str,Any] - the modifications to apply.
        :param session: Optional[AsyncIOMotorClientSession]
        :param bulk_writer: Optional[BulkWriter]
        :param response_type: Optional[UpdateResponse]
        :return: UpdateMany query
        """

    def upsert(
        self,
        *args: Mapping[str, Any],
        on_insert: DocType,
        session: AsyncIOMotorClientSession | None = ...,
        response_type: UpdateResponse | None = ...,
        **pymongo_kwargs,
    ):  # -> UpdateQuery:
        """
        Create Update with modifications query
        and provide search criteria there

        :param args: *Mapping[str,Any] - the modifications to apply.
        :param on_insert: DocType - document to insert if there is no matched
        document in the collection
        :param session: Optional[AsyncIOMotorClientSession]
        :param response_type: Optional[UpdateResponse]
        :return: UpdateMany query
        """

    def update_one(
        self,
        *args: Mapping[str, Any],
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        response_type: UpdateResponse | None = ...,
        **pymongo_kwargs,
    ) -> UpdateOne:
        """
        Create [UpdateOne](query.md#updateone) query using modifications and
        provide search criteria there
        :param args: *Mapping[str,Any] - the modifications to apply
        :param session: Optional[AsyncIOMotorClientSession] - PyMongo sessions
        :param response_type: Optional[UpdateResponse]
        :return: [UpdateOne](query.md#updateone) query
        """

    def delete_one(
        self,
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        **pymongo_kwargs,
    ) -> DeleteOne:
        """
        Provide search criteria to the [DeleteOne](query.md#deleteone) query
        :param session: Optional[AsyncIOMotorClientSession] - PyMongo sessions
        :return: [DeleteOne](query.md#deleteone) query
        """

    async def replace_one(
        self,
        document: DocType,
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
    ) -> UpdateResult | None:
        """
        Replace found document by provided
        :param document: Document - document, which will replace the found one
        :param session: Optional[AsyncIOMotorClientSession] - PyMongo session
        :param bulk_writer: Optional[BulkWriter] - Beanie bulk writer
        :return: UpdateResult
        """

    def __await__(self) -> Generator[Coroutine, Any, FindQueryResultType | None]:
        """
        Run the query
        :return: BaseModel
        """

    async def count(self) -> int:
        """
        Count the number of documents matching the query
        :return: int
        """
