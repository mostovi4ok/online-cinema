"""
This type stub file was generated by pyright.
"""

from collections.abc import Callable, Coroutine, Iterable, Mapping
from datetime import datetime
from enum import StrEnum
from typing import TYPE_CHECKING, Any, ClassVar, Concatenate, Self, TypeAlias, TypeVar
from uuid import UUID

from beanie.odm.actions import ActionDirections, EventTypes, wrap_with_actions
from beanie.odm.bulk import BulkWriter
from beanie.odm.cache import LRUCache
from beanie.odm.enums import SortDirection
from beanie.odm.fields import DeleteRules, ExpressionField, LinkInfo, PydanticObjectId, WriteRules
from beanie.odm.interfaces.aggregate import AggregateInterface
from beanie.odm.interfaces.detector import ModelType
from beanie.odm.interfaces.find import FindInterface
from beanie.odm.interfaces.getters import OtherGettersInterface
from beanie.odm.interfaces.inheritance import InheritanceInterface
from beanie.odm.interfaces.setters import SettersInterface
from beanie.odm.models import InspectionResult
from beanie.odm.queries.find import FindMany, FindOne
from beanie.odm.queries.update import UpdateMany
from beanie.odm.settings.document import DocumentSettings
from beanie.odm.utils.pydantic import IS_PYDANTIC_V2
from beanie.odm.utils.self_validation import validate_self_before
from beanie.odm.utils.state import previous_saved_state_needed, save_state_after, saved_state_needed
from beanie.odm.views import View
from lazy_model import LazyModel
from motor.motor_asyncio import AsyncIOMotorClientSession
from pydantic import model_validator
from pydantic.class_validators import root_validator
from pydantic.main import BaseModel
from pymongo.results import DeleteResult, InsertManyResult
from typing_extensions import ParamSpec

if IS_PYDANTIC_V2: ...
if TYPE_CHECKING: ...
FindType = TypeVar("FindType", bound=Document | View)
DocType = TypeVar("DocType", bound=Document)
P = ParamSpec("P")
R = TypeVar("R")
AnyDocMethod: TypeAlias = Callable[Concatenate[DocType, P], R]
AsyncDocMethod: TypeAlias = Callable[Concatenate[DocType, P], Coroutine[Any, Any, R]]
DocumentProjectionType = TypeVar("DocumentProjectionType", bound=BaseModel)

def json_schema_extra(schema: dict[str, Any], model: type[Document]) -> None: ...
def document_alias_generator(s: str) -> str: ...

class MergeStrategy(StrEnum):
    local = ...
    remote = ...

class Document(
    LazyModel, SettersInterface, InheritanceInterface, FindInterface, AggregateInterface, OtherGettersInterface
):
    """
    Document Mapping class.

    Fields:

    - `id` - MongoDB document ObjectID "_id" field.
    Mapped to the PydanticObjectId class
    """

    if IS_PYDANTIC_V2:
        model_config = ...
    else:
        class Config:
            json_encoders = ...
            allow_population_by_field_name = ...
            fields = ...
            schema_extra = ...

    id: PydanticObjectId | None = ...
    revision_id: UUID | None = ...
    _saved_state: dict[str, Any] | None = ...
    _previous_saved_state: dict[str, Any] | None = ...
    _link_fields: ClassVar[dict[str, LinkInfo] | None] = ...
    _cache: ClassVar[LRUCache | None] = ...
    _document_settings: ClassVar[DocumentSettings | None] = ...
    _database_major_version: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

    if IS_PYDANTIC_V2:
        @model_validator(mode="before")
        def fill_back_refs(cls, values): ...

    else:
        @root_validator(pre=True)
        def fill_back_refs(cls, values): ...

    @classmethod
    async def get(
        cls: type[DocType],
        document_id: Any,
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        fetch_links: bool = ...,
        with_children: bool = ...,
        nesting_depth: int | None = ...,
        nesting_depths_per_field: dict[str, int] | None = ...,
        **pymongo_kwargs,
    ) -> DocType | None:
        """
        Get document by id, returns None if document does not exist

        :param document_id: PydanticObjectId - document id
        :param session: Optional[AsyncIOMotorClientSession] - motor session
        :param ignore_cache: bool - ignore cache (if it is turned on)
        :param **pymongo_kwargs: pymongo native parameters for find operation
        :return: Union["Document", None]
        """

    async def sync(self, merge_strategy: MergeStrategy = ...):  # -> None:
        """
        Sync the document with the database

        :param merge_strategy: MergeStrategy - how to merge the document
        :return: None
        """

    @wrap_with_actions(EventTypes.INSERT)
    @save_state_after
    @validate_self_before
    async def insert(
        self: Self,
        *,
        link_rule: WriteRules = ...,
        session: AsyncIOMotorClientSession | None = ...,
        skip_actions: list[ActionDirections | str] | None = ...,
    ) -> Self:
        """
        Insert the document (self) to the collection
        :return: self
        """

    async def create(self: Self, session: AsyncIOMotorClientSession | None = ...) -> Self:
        """
        The same as self.insert()
        :return: self
        """

    @classmethod
    async def insert_one(
        cls: type[DocType],
        document: DocType,
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        link_rule: WriteRules = ...,
    ) -> DocType | None:
        """
        Insert one document to the collection
        :param document: Document - document to insert
        :param session: AsyncIOMotorClientSession - motor session
        :param bulk_writer: "BulkWriter" - Beanie bulk writer
        :param link_rule: InsertRules - hot to manage link fields
        :return: DocType
        """

    @classmethod
    async def insert_many(
        cls: type[DocType],
        documents: Iterable[DocType],
        session: AsyncIOMotorClientSession | None = ...,
        link_rule: WriteRules = ...,
        **pymongo_kwargs: Any,
    ) -> InsertManyResult:
        """
        Insert many documents to the collection

        :param documents:  List["Document"] - documents to insert
        :param session: AsyncIOMotorClientSession - motor session
        :param link_rule: InsertRules - how to manage link fields
        :return: InsertManyResult
        """

    @wrap_with_actions(EventTypes.REPLACE)
    @save_state_after
    @validate_self_before
    async def replace(
        self: Self,
        ignore_revision: bool = ...,
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        link_rule: WriteRules = ...,
        skip_actions: list[ActionDirections | str] | None = ...,
    ) -> Self:
        """
        Fully update the document in the database

        :param session: Optional[AsyncIOMotorClientSession] - motor session.
        :param ignore_revision: bool - do force replace.
            Used when revision based protection is turned on.
        :param bulk_writer: "BulkWriter" - Beanie bulk writer
        :return: self
        """

    @wrap_with_actions(EventTypes.SAVE)
    @save_state_after
    @validate_self_before
    async def save(
        self: Self,
        session: AsyncIOMotorClientSession | None = ...,
        link_rule: WriteRules = ...,
        ignore_revision: bool = ...,
        **kwargs: Any,
    ) -> Self:
        """
        Update an existing model in the database or
        insert it if it does not yet exist.

        :param session: Optional[AsyncIOMotorClientSession] - motor session.
        :param link_rule: WriteRules - rules how to deal with links on writing
        :param ignore_revision: bool - do force save.
        :return: self
        """

    @saved_state_needed
    @wrap_with_actions(EventTypes.SAVE_CHANGES)
    @validate_self_before
    async def save_changes(
        self: Self,
        ignore_revision: bool = ...,
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        skip_actions: list[ActionDirections | str] | None = ...,
    ) -> Self | None:
        """
        Save changes.
        State management usage must be turned on

        :param ignore_revision: bool - ignore revision id, if revision is turned on
        :param bulk_writer: "BulkWriter" - Beanie bulk writer
        :return: Optional[self]
        """

    @classmethod
    async def replace_many(
        cls: type[DocType], documents: list[DocType], session: AsyncIOMotorClientSession | None = ...
    ) -> None:
        """
        Replace list of documents

        :param documents: List["Document"]
        :param session: Optional[AsyncIOMotorClientSession] - motor session.
        :return: None
        """

    @wrap_with_actions(EventTypes.UPDATE)
    @save_state_after
    async def update(
        self: Self,
        *args,
        ignore_revision: bool = ...,
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        skip_actions: list[ActionDirections | str] | None = ...,
        skip_sync: bool | None = ...,
        **pymongo_kwargs,
    ) -> Self:
        """
        Partially update the document in the database

        :param args: *Union[dict, Mapping] - the modifications to apply.
        :param session: AsyncIOMotorClientSession - motor session.
        :param ignore_revision: bool - force update. Will update even if revision id is not the same, as stored
        :param bulk_writer: "BulkWriter" - Beanie bulk writer
        :param pymongo_kwargs: pymongo native parameters for update operation
        :return: self
        """

    @classmethod
    def update_all(
        cls,
        *args: dict | Mapping,
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        **pymongo_kwargs,
    ) -> UpdateMany:
        """
        Partially update all the documents

        :param args: *Union[dict, Mapping] - the modifications to apply.
        :param session: AsyncIOMotorClientSession - motor session.
        :param bulk_writer: "BulkWriter" - Beanie bulk writer
        :param **pymongo_kwargs: pymongo native parameters for find operation
        :return: UpdateMany query
        """

    def set(
        self: Self,
        expression: dict[ExpressionField | str | Any, Any],
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        skip_sync: bool | None = ...,
        **kwargs,
    ) -> Coroutine[None, None, Self]:
        """
        Set values

        Example:
        ```python
        class Sample(Document):
            one: int

        await Document.find(Sample.one == 1).set({Sample.one: 100})
        ```

        Uses [Set operator](operators/update.md#set)

        :param expression: Dict[Union[ExpressionField, str, Any], Any] - keys and
        values to set
        :param session: Optional[AsyncIOMotorClientSession] - motor session
        :param bulk_writer: Optional[BulkWriter] - bulk writer
        :param skip_sync: bool - skip doc syncing. Available for the direct instances only
        :return: self

        """

    def current_date(
        self: Self,
        expression: dict[datetime | ExpressionField | str, Any],
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        skip_sync: bool | None = ...,
        **kwargs,
    ) -> Coroutine[None, None, Self]:
        """
        Set current date

        Uses [CurrentDate operator](operators/update.md#currentdate)

        :param expression: Dict[Union[datetime, ExpressionField, str], Any]
        :param session: Optional[AsyncIOMotorClientSession] - motor session
        :param bulk_writer: Optional[BulkWriter] - bulk writer
        :param skip_sync: bool - skip doc syncing. Available for the direct instances only
        :return: self
        """

    def inc(
        self: Self,
        expression: dict[ExpressionField | float | int | str, Any],
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        skip_sync: bool | None = ...,
        **kwargs,
    ) -> Coroutine[None, None, Self]:
        """
        Increment

        Example:
        ```python
        class Sample(Document):
            one: int

        await Document.find(Sample.one == 1).inc({Sample.one: 100})
        ```

        Uses [Inc operator](operators/update.md#inc)

        :param expression: Dict[Union[ExpressionField, float, int, str], Any]
        :param session: Optional[AsyncIOMotorClientSession] - motor session
        :param bulk_writer: Optional[BulkWriter] - bulk writer
        :param skip_sync: bool - skip doc syncing. Available for the direct instances only
        :return: self

        """

    @wrap_with_actions(EventTypes.DELETE)
    async def delete(
        self,
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        link_rule: DeleteRules = ...,
        skip_actions: list[ActionDirections | str] | None = ...,
        **pymongo_kwargs: Any,
    ) -> DeleteResult | None:
        """
        Delete the document

        :param session: Optional[AsyncIOMotorClientSession] - motor session.
        :param bulk_writer: "BulkWriter" - Beanie bulk writer
        :param link_rule: DeleteRules - rules for link fields
        :param **pymongo_kwargs: pymongo native parameters for delete operation
        :return: Optional[DeleteResult] - pymongo DeleteResult instance.
        """

    @classmethod
    async def delete_all(
        cls,
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        **pymongo_kwargs,
    ) -> DeleteResult | None:
        """
        Delete all the documents

        :param session: Optional[AsyncIOMotorClientSession] - motor session.
        :param bulk_writer: "BulkWriter" - Beanie bulk writer
        :param **pymongo_kwargs: pymongo native parameters for delete operation
        :return: Optional[DeleteResult] - pymongo DeleteResult instance.
        """

    @classmethod
    def use_state_management(cls) -> bool:
        """
        Is state management turned on
        :return: bool
        """

    @classmethod
    def state_management_save_previous(cls) -> bool:
        """
        Should we save the previous state after a commit to database
        :return: bool
        """

    @classmethod
    def state_management_replace_objects(cls) -> bool:
        """
        Should objects be replaced when using state management
        :return: bool
        """

    def get_saved_state(self) -> dict[str, Any] | None:
        """
        Saved state getter. It is protected property.
        :return: Optional[Dict[str, Any]] - saved state
        """

    def get_previous_saved_state(self) -> dict[str, Any] | None:
        """
        Previous state getter. It is a protected property.
        :return: Optional[Dict[str, Any]] - previous state
        """

    @property
    @saved_state_needed
    def is_changed(self) -> bool: ...
    @property
    @saved_state_needed
    @previous_saved_state_needed
    def has_changed(self) -> bool: ...
    @saved_state_needed
    def get_changes(self) -> dict[str, Any]: ...
    @saved_state_needed
    @previous_saved_state_needed
    def get_previous_changes(self) -> dict[str, Any]: ...
    @saved_state_needed
    def rollback(self) -> None: ...
    @classmethod
    def get_settings(cls) -> DocumentSettings:
        """
        Get document settings, which was created on
        the initialization step

        :return: DocumentSettings class
        """

    @classmethod
    async def inspect_collection(cls, session: AsyncIOMotorClientSession | None = ...) -> InspectionResult:
        """
        Check, if documents, stored in the MongoDB collection
        are compatible with the Document schema

        :return: InspectionResult
        """

    @classmethod
    def check_hidden_fields(cls):  # -> None:
        ...
    @wrap_with_actions(event_type=EventTypes.VALIDATE_ON_SAVE)
    async def validate_self(self, *args, **kwargs):  # -> None:
        ...
    def to_ref(self):  # -> DBRef:
        ...
    async def fetch_link(self, field: str | Any):  # -> None:
        ...
    async def fetch_all_links(self):  # -> None:
        ...
    @classmethod
    def get_link_fields(cls) -> dict[str, LinkInfo] | None: ...
    @classmethod
    def get_model_type(cls) -> ModelType: ...
    @classmethod
    async def distinct(
        cls,
        key: str,
        filter: Mapping[str, Any] | None = ...,
        session: AsyncIOMotorClientSession | None = ...,
        **kwargs: Any,
    ) -> list: ...
    @classmethod
    def link_from_id(cls, id: Any):  # -> Link[Self]:
        ...

class DocumentWithSoftDelete(Document):
    deleted_at: datetime | None = ...
    def is_deleted(self) -> bool: ...
    async def hard_delete(
        self,
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        link_rule: DeleteRules = ...,
        skip_actions: list[ActionDirections | str] | None = ...,
        **pymongo_kwargs,
    ) -> DeleteResult | None: ...
    async def delete(
        self,
        session: AsyncIOMotorClientSession | None = ...,
        bulk_writer: BulkWriter | None = ...,
        link_rule: DeleteRules = ...,
        skip_actions: list[ActionDirections | str] | None = ...,
        **pymongo_kwargs: Any,
    ) -> DeleteResult | None: ...
    @classmethod
    def find_many_in_all(
        cls: type[FindType],
        *args: Mapping[str, Any] | bool,
        projection_model: None = ...,
        skip: int | None = ...,
        limit: int | None = ...,
        sort: None | str | list[tuple[str, SortDirection]] = ...,
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        fetch_links: bool = ...,
        with_children: bool = ...,
        lazy_parse: bool = ...,
        nesting_depth: int | None = ...,
        nesting_depths_per_field: dict[str, int] | None = ...,
        **pymongo_kwargs,
    ) -> FindMany[FindType] | FindMany[DocumentProjectionType]: ...
    @classmethod
    def find_many(
        cls: type[FindType],
        *args: Mapping[str, Any] | bool,
        projection_model: type[DocumentProjectionType] | None = ...,
        skip: int | None = ...,
        limit: int | None = ...,
        sort: None | str | list[tuple[str, SortDirection]] = ...,
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        fetch_links: bool = ...,
        with_children: bool = ...,
        lazy_parse: bool = ...,
        nesting_depth: int | None = ...,
        nesting_depths_per_field: dict[str, int] | None = ...,
        **pymongo_kwargs: Any,
    ) -> FindMany[FindType] | FindMany[DocumentProjectionType]: ...
    @classmethod
    def find_one(
        cls: type[FindType],
        *args: Mapping[str, Any] | bool,
        projection_model: type[DocumentProjectionType] | None = ...,
        session: AsyncIOMotorClientSession | None = ...,
        ignore_cache: bool = ...,
        fetch_links: bool = ...,
        with_children: bool = ...,
        nesting_depth: int | None = ...,
        nesting_depths_per_field: dict[str, int] | None = ...,
        **pymongo_kwargs,
    ) -> FindOne[FindType] | FindOne[DocumentProjectionType]: ...
