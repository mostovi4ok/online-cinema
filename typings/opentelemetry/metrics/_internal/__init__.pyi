"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod
from collections.abc import Sequence
from typing import TypeAlias

from opentelemetry.metrics._internal.instrument import (
    CallbackT,
    Counter,
    Gauge,
    Histogram,
    ObservableCounter,
    ObservableGauge,
    ObservableUpDownCounter,
    UpDownCounter,
    _ProxyCounter,
    _ProxyGauge,
    _ProxyHistogram,
    _ProxyObservableCounter,
    _ProxyObservableGauge,
    _ProxyObservableUpDownCounter,
    _ProxyUpDownCounter,
)
from opentelemetry.util.types import Attributes

"""
The OpenTelemetry metrics API  describes the classes used to generate
metrics.

The :class:`.MeterProvider` provides users access to the :class:`.Meter` which in
turn is used to create :class:`.Instrument` objects. The :class:`.Instrument` objects are
used to record measurements.

This module provides abstract (i.e. unimplemented) classes required for
metrics, and a concrete no-op implementation :class:`.NoOpMeter` that allows applications
to use the API package alone without a supporting implementation.

To get a meter, you need to provide the package name from which you are
calling the meter APIs to OpenTelemetry by calling `MeterProvider.get_meter`
with the calling instrumentation name and the version of your package.

The following code shows how to obtain a meter using the global :class:`.MeterProvider`::

    from opentelemetry.metrics import get_meter

    meter = get_meter("example-meter")
    counter = meter.create_counter("example-counter")

.. versionadded:: 1.10.0
"""
_logger = ...
_ProxyInstrumentT: TypeAlias = (
    _ProxyCounter
    | _ProxyHistogram
    | _ProxyGauge
    | _ProxyObservableCounter
    | _ProxyObservableGauge
    | _ProxyObservableUpDownCounter
    | _ProxyUpDownCounter
)

class MeterProvider(ABC):
    """
    MeterProvider is the entry point of the API. It provides access to `Meter` instances.
    """

    @abstractmethod
    def get_meter(
        self, name: str, version: str | None = ..., schema_url: str | None = ..., attributes: Attributes | None = ...
    ) -> Meter:
        """Returns a `Meter` for use by the given instrumentation library.

        For any two calls it is undefined whether the same or different
        `Meter` instances are returned, even for different library names.

        This function may return different `Meter` types (e.g. a no-op meter
        vs. a functional meter).

        Args:
            name: The name of the instrumenting module.
                ``__name__`` may not be used as this can result in
                different meter names if the meters are in different files.
                It is better to use a fixed string that can be imported where
                needed and used consistently as the name of the meter.

                This should *not* be the name of the module that is
                instrumented but the name of the module doing the instrumentation.
                E.g., instead of ``"requests"``, use
                ``"opentelemetry.instrumentation.requests"``.

            version: Optional. The version string of the
                instrumenting library.  Usually this should be the same as
                ``importlib.metadata.version(instrumenting_library_name)``.

            schema_url: Optional. Specifies the Schema URL of the emitted telemetry.
            attributes: Optional. Attributes that are associated with the emitted telemetry.

        """
        ...

class NoOpMeterProvider(MeterProvider):
    """The default MeterProvider used when no MeterProvider implementation is available."""

    def get_meter(
        self, name: str, version: str | None = ..., schema_url: str | None = ..., attributes: Attributes | None = ...
    ) -> Meter:
        """Returns a NoOpMeter."""

class _ProxyMeterProvider(MeterProvider):
    def __init__(self) -> None: ...
    def get_meter(
        self, name: str, version: str | None = ..., schema_url: str | None = ..., attributes: Attributes | None = ...
    ) -> Meter: ...
    def on_set_meter_provider(self, meter_provider: MeterProvider) -> None: ...

class Meter(ABC):
    """Handles instrument creation.

    This class provides methods for creating instruments which are then
    used to produce measurements.
    """

    def __init__(self, name: str, version: str | None = ..., schema_url: str | None = ...) -> None: ...
    @property
    def name(self) -> str:
        """
        The name of the instrumenting module.
        """

    @property
    def version(self) -> str | None:
        """
        The version string of the instrumenting library.
        """

    @property
    def schema_url(self) -> str | None:
        """
        Specifies the Schema URL of the emitted telemetry
        """

    @abstractmethod
    def create_counter(self, name: str, unit: str = ..., description: str = ...) -> Counter:
        """Creates a `Counter` instrument

        Args:
            name: The name of the instrument to be created
            unit: The unit for observations this instrument reports. For
                example, ``By`` for bytes. UCUM units are recommended.
            description: A description for this instrument and what it measures.

        """
        ...

    @abstractmethod
    def create_up_down_counter(self, name: str, unit: str = ..., description: str = ...) -> UpDownCounter:
        """Creates an `UpDownCounter` instrument

        Args:
            name: The name of the instrument to be created
            unit: The unit for observations this instrument reports. For
                example, ``By`` for bytes. UCUM units are recommended.
            description: A description for this instrument and what it measures.

        """
        ...

    @abstractmethod
    def create_observable_counter(
        self, name: str, callbacks: Sequence[CallbackT] | None = ..., unit: str = ..., description: str = ...
    ) -> ObservableCounter:
        """Creates an `ObservableCounter` instrument

        An observable counter observes a monotonically increasing count by calling provided
        callbacks which accept a :class:`~opentelemetry.metrics.CallbackOptions` and return
        multiple :class:`~opentelemetry.metrics.Observation`.

        For example, an observable counter could be used to report system CPU
        time periodically. Here is a basic implementation::

            def cpu_time_callback(options: CallbackOptions) -> Iterable[Observation]:
                observations = []
                with open("/proc/stat") as procstat:
                    procstat.readline()  # skip the first line
                    for line in procstat:
                        if not line.startswith("cpu"):
                            break
                        cpu, *states = line.split()
                        observations.append(Observation(int(states[0]) // 100, {"cpu": cpu, "state": "user"}))
                        observations.append(Observation(int(states[1]) // 100, {"cpu": cpu, "state": "nice"}))
                        observations.append(Observation(int(states[2]) // 100, {"cpu": cpu, "state": "system"}))
                        # ... other states
                return observations

            meter.create_observable_counter(
                "system.cpu.time", callbacks=[cpu_time_callback], unit="s", description="CPU time"
            )

        To reduce memory usage, you can use generator callbacks instead of
        building the full list::

            def cpu_time_callback(options: CallbackOptions) -> Iterable[Observation]:
                with open("/proc/stat") as procstat:
                    procstat.readline()  # skip the first line
                    for line in procstat:
                        if not line.startswith("cpu"):
                            break
                        cpu, *states = line.split()
                        yield Observation(int(states[0]) // 100, {"cpu": cpu, "state": "user"})
                        yield Observation(int(states[1]) // 100, {"cpu": cpu, "state": "nice"})
                        # ... other states

        Alternatively, you can pass a sequence of generators directly instead of a sequence of
        callbacks, which each should return iterables of :class:`~opentelemetry.metrics.Observation`::

            def cpu_time_callback(states_to_include: set[str]) -> Iterable[Iterable[Observation]]:
                # accept options sent in from OpenTelemetry
                options = yield
                while True:
                    observations = []
                    with open("/proc/stat") as procstat:
                        procstat.readline()  # skip the first line
                        for line in procstat:
                            if not line.startswith("cpu"):
                                break
                            cpu, *states = line.split()
                            if "user" in states_to_include:
                                observations.append(Observation(int(states[0]) // 100, {"cpu": cpu, "state": "user"}))
                            if "nice" in states_to_include:
                                observations.append(Observation(int(states[1]) // 100, {"cpu": cpu, "state": "nice"}))
                            # ... other states
                    # yield the observations and receive the options for next iteration
                    options = yield observations

            meter.create_observable_counter(
                "system.cpu.time", callbacks=[cpu_time_callback({"user", "system"})], unit="s", description="CPU time"
            )

        The :class:`~opentelemetry.metrics.CallbackOptions` contain a timeout which the
        callback should respect. For example if the callback does asynchronous work, like
        making HTTP requests, it should respect the timeout::

            def scrape_http_callback(options: CallbackOptions) -> Iterable[Observation]:
                r = requests.get("http://scrapethis.com", timeout=options.timeout_millis / 10**3)
                for value in r.json():
                    yield Observation(value)

        Args:
            name: The name of the instrument to be created
            callbacks: A sequence of callbacks that return an iterable of
                :class:`~opentelemetry.metrics.Observation`. Alternatively, can be a sequence of generators that each
                yields iterables of :class:`~opentelemetry.metrics.Observation`.
            unit: The unit for observations this instrument reports. For
                example, ``By`` for bytes. UCUM units are recommended.
            description: A description for this instrument and what it measures.

        """
        ...

    @abstractmethod
    def create_histogram(self, name: str, unit: str = ..., description: str = ...) -> Histogram:
        """Creates a :class:`~opentelemetry.metrics.Histogram` instrument

        Args:
            name: The name of the instrument to be created
            unit: The unit for observations this instrument reports. For
                example, ``By`` for bytes. UCUM units are recommended.
            description: A description for this instrument and what it measures.

        """
        ...

    def create_gauge(self, name: str, unit: str = ..., description: str = ...) -> Gauge:
        """Creates a ``Gauge`` instrument

        Args:
            name: The name of the instrument to be created
            unit: The unit for observations this instrument reports. For
                example, ``By`` for bytes. UCUM units are recommended.
            description: A description for this instrument and what it measures.

        """

    @abstractmethod
    def create_observable_gauge(
        self, name: str, callbacks: Sequence[CallbackT] | None = ..., unit: str = ..., description: str = ...
    ) -> ObservableGauge:
        """Creates an `ObservableGauge` instrument

        Args:
            name: The name of the instrument to be created
            callbacks: A sequence of callbacks that return an iterable of
                :class:`~opentelemetry.metrics.Observation`. Alternatively, can be a generator that yields iterables
                of :class:`~opentelemetry.metrics.Observation`.
            unit: The unit for observations this instrument reports. For
                example, ``By`` for bytes. UCUM units are recommended.
            description: A description for this instrument and what it measures.

        """
        ...

    @abstractmethod
    def create_observable_up_down_counter(
        self, name: str, callbacks: Sequence[CallbackT] | None = ..., unit: str = ..., description: str = ...
    ) -> ObservableUpDownCounter:
        """Creates an `ObservableUpDownCounter` instrument

        Args:
            name: The name of the instrument to be created
            callbacks: A sequence of callbacks that return an iterable of
                :class:`~opentelemetry.metrics.Observation`. Alternatively, can be a generator that yields iterables
                of :class:`~opentelemetry.metrics.Observation`.
            unit: The unit for observations this instrument reports. For
                example, ``By`` for bytes. UCUM units are recommended.
            description: A description for this instrument and what it measures.

        """
        ...

class _ProxyMeter(Meter):
    def __init__(self, name: str, version: str | None = ..., schema_url: str | None = ...) -> None: ...
    def on_set_meter_provider(self, meter_provider: MeterProvider) -> None:
        """Called when a real meter provider is set on the creating _ProxyMeterProvider

        Creates a real backing meter for this instance and notifies all created
        instruments so they can create real backing instruments.
        """

    def create_counter(self, name: str, unit: str = ..., description: str = ...) -> Counter: ...
    def create_up_down_counter(self, name: str, unit: str = ..., description: str = ...) -> UpDownCounter: ...
    def create_observable_counter(
        self, name: str, callbacks: Sequence[CallbackT] | None = ..., unit: str = ..., description: str = ...
    ) -> ObservableCounter: ...
    def create_histogram(self, name: str, unit: str = ..., description: str = ...) -> Histogram: ...
    def create_gauge(self, name: str, unit: str = ..., description: str = ...) -> Gauge: ...
    def create_observable_gauge(
        self, name: str, callbacks: Sequence[CallbackT] | None = ..., unit: str = ..., description: str = ...
    ) -> ObservableGauge: ...
    def create_observable_up_down_counter(
        self, name: str, callbacks: Sequence[CallbackT] | None = ..., unit: str = ..., description: str = ...
    ) -> ObservableUpDownCounter: ...

class NoOpMeter(Meter):
    """The default Meter used when no Meter implementation is available.

    All operations are no-op.
    """

    def create_counter(self, name: str, unit: str = ..., description: str = ...) -> Counter:
        """Returns a no-op Counter."""

    def create_gauge(self, name: str, unit: str = ..., description: str = ...) -> Gauge:
        """Returns a no-op Gauge."""

    def create_up_down_counter(self, name: str, unit: str = ..., description: str = ...) -> UpDownCounter:
        """Returns a no-op UpDownCounter."""

    def create_observable_counter(
        self, name: str, callbacks: Sequence[CallbackT] | None = ..., unit: str = ..., description: str = ...
    ) -> ObservableCounter:
        """Returns a no-op ObservableCounter."""

    def create_histogram(self, name: str, unit: str = ..., description: str = ...) -> Histogram:
        """Returns a no-op Histogram."""

    def create_observable_gauge(
        self, name: str, callbacks: Sequence[CallbackT] | None = ..., unit: str = ..., description: str = ...
    ) -> ObservableGauge:
        """Returns a no-op ObservableGauge."""

    def create_observable_up_down_counter(
        self, name: str, callbacks: Sequence[CallbackT] | None = ..., unit: str = ..., description: str = ...
    ) -> ObservableUpDownCounter:
        """Returns a no-op ObservableUpDownCounter."""

_METER_PROVIDER_SET_ONCE = ...
_METER_PROVIDER: MeterProvider | None = ...
_PROXY_METER_PROVIDER = ...

def get_meter(
    name: str, version: str = ..., meter_provider: MeterProvider | None = ..., schema_url: str | None = ...
) -> Meter:
    """Returns a `Meter` for use by the given instrumentation library.

    This function is a convenience wrapper for
    `opentelemetry.metrics.MeterProvider.get_meter`.

    If meter_provider is omitted the current configured one is used.
    """

def set_meter_provider(meter_provider: MeterProvider) -> None:
    """Sets the current global :class:`~.MeterProvider` object.

    This can only be done once, a warning will be logged if any further attempt
    is made.
    """

def get_meter_provider() -> MeterProvider:
    """Gets the current global :class:`~.MeterProvider` object."""
