"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod
from collections.abc import Callable, Generator, Iterable, Sequence
from dataclasses import dataclass
from typing import Generic, TypeAlias, TypeVar

from opentelemetry import metrics
from opentelemetry.metrics._internal.observation import Observation
from opentelemetry.util.types import Attributes

_logger = ...
_name_regex = ...
_unit_regex = ...

@dataclass(frozen=True)
class CallbackOptions:
    """Options for the callback

    Args:
        timeout_millis: Timeout for the callback's execution. If the callback does asynchronous
            work (e.g. HTTP requests), it should respect this timeout.

    """

    timeout_millis: float = ...

InstrumentT = TypeVar("InstrumentT", bound=Instrument)
CallbackT: TypeAlias = (
    Callable[[CallbackOptions], Iterable[Observation]] | Generator[Iterable[Observation], CallbackOptions, None]
)

class Instrument(ABC):
    """Abstract class that serves as base for all instruments."""

    @abstractmethod
    def __init__(self, name: str, unit: str = ..., description: str = ...) -> None: ...

class _ProxyInstrument(ABC, Generic[InstrumentT]):
    def __init__(self, name: str, unit: str = ..., description: str = ...) -> None: ...
    def on_meter_set(self, meter: metrics.Meter) -> None:
        """Called when a real meter is set on the creating _ProxyMeter"""

class _ProxyAsynchronousInstrument(_ProxyInstrument[InstrumentT]):
    def __init__(
        self, name: str, callbacks: Sequence[CallbackT] | None = ..., unit: str = ..., description: str = ...
    ) -> None: ...

class Synchronous(Instrument):
    """Base class for all synchronous instruments"""

class Asynchronous(Instrument):
    """Base class for all asynchronous instruments"""

    @abstractmethod
    def __init__(
        self, name: str, callbacks: Sequence[CallbackT] | None = ..., unit: str = ..., description: str = ...
    ) -> None: ...

class Counter(Synchronous):
    """A Counter is a synchronous `Instrument` which supports non-negative increments."""

    @abstractmethod
    def add(self, amount: int | float, attributes: Attributes | None = ...) -> None: ...

class NoOpCounter(Counter):
    """No-op implementation of `Counter`."""

    def __init__(self, name: str, unit: str = ..., description: str = ...) -> None: ...
    def add(self, amount: int | float, attributes: Attributes | None = ...) -> None: ...

class _ProxyCounter(_ProxyInstrument[Counter], Counter):
    def add(self, amount: int | float, attributes: Attributes | None = ...) -> None: ...

class UpDownCounter(Synchronous):
    """An UpDownCounter is a synchronous `Instrument` which supports increments and decrements."""

    @abstractmethod
    def add(self, amount: int | float, attributes: Attributes | None = ...) -> None: ...

class NoOpUpDownCounter(UpDownCounter):
    """No-op implementation of `UpDownCounter`."""

    def __init__(self, name: str, unit: str = ..., description: str = ...) -> None: ...
    def add(self, amount: int | float, attributes: Attributes | None = ...) -> None: ...

class _ProxyUpDownCounter(_ProxyInstrument[UpDownCounter], UpDownCounter):
    def add(self, amount: int | float, attributes: Attributes | None = ...) -> None: ...

class ObservableCounter(Asynchronous):
    """An ObservableCounter is an asynchronous `Instrument` which reports monotonically
    increasing value(s) when the instrument is being observed.
    """

class NoOpObservableCounter(ObservableCounter):
    """No-op implementation of `ObservableCounter`."""

    def __init__(
        self, name: str, callbacks: Sequence[CallbackT] | None = ..., unit: str = ..., description: str = ...
    ) -> None: ...

class _ProxyObservableCounter(_ProxyAsynchronousInstrument[ObservableCounter], ObservableCounter): ...

class ObservableUpDownCounter(Asynchronous):
    """An ObservableUpDownCounter is an asynchronous `Instrument` which reports additive value(s) (e.g.
    the process heap size - it makes sense to report the heap size from multiple processes and sum them
    up, so we get the total heap usage) when the instrument is being observed.
    """

class NoOpObservableUpDownCounter(ObservableUpDownCounter):
    """No-op implementation of `ObservableUpDownCounter`."""

    def __init__(
        self, name: str, callbacks: Sequence[CallbackT] | None = ..., unit: str = ..., description: str = ...
    ) -> None: ...

class _ProxyObservableUpDownCounter(_ProxyAsynchronousInstrument[ObservableUpDownCounter], ObservableUpDownCounter): ...

class Histogram(Synchronous):
    """Histogram is a synchronous `Instrument` which can be used to report arbitrary values
    that are likely to be statistically meaningful. It is intended for statistics such as
    histograms, summaries, and percentile.
    """

    @abstractmethod
    def record(self, amount: int | float, attributes: Attributes | None = ...) -> None: ...

class NoOpHistogram(Histogram):
    """No-op implementation of `Histogram`."""

    def __init__(self, name: str, unit: str = ..., description: str = ...) -> None: ...
    def record(self, amount: int | float, attributes: Attributes | None = ...) -> None: ...

class _ProxyHistogram(_ProxyInstrument[Histogram], Histogram):
    def record(self, amount: int | float, attributes: Attributes | None = ...) -> None: ...

class ObservableGauge(Asynchronous):
    """Asynchronous Gauge is an asynchronous `Instrument` which reports non-additive value(s) (e.g.
    the room temperature - it makes no sense to report the temperature value from multiple rooms
    and sum them up) when the instrument is being observed.
    """

class NoOpObservableGauge(ObservableGauge):
    """No-op implementation of `ObservableGauge`."""

    def __init__(
        self, name: str, callbacks: Sequence[CallbackT] | None = ..., unit: str = ..., description: str = ...
    ) -> None: ...

class _ProxyObservableGauge(_ProxyAsynchronousInstrument[ObservableGauge], ObservableGauge): ...

class Gauge(Synchronous):
    """A Gauge is a synchronous `Instrument` which can be used to record non-additive values as they occur."""

    @abstractmethod
    def set(self, amount: int | float, attributes: Attributes | None = ...) -> None: ...

class NoOpGauge(Gauge):
    """No-op implementation of ``Gauge``."""

    def __init__(self, name: str, unit: str = ..., description: str = ...) -> None: ...
    def set(self, amount: int | float, attributes: Attributes | None = ...) -> None: ...

class _ProxyGauge(_ProxyInstrument[Gauge], Gauge):
    def set(self, amount: int | float, attributes: Attributes | None = ...) -> None: ...
