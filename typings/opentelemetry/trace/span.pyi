"""
This type stub file was generated by pyright.
"""

import abc
import types as python_types
import typing

from opentelemetry.trace.status import Status, StatusCode
from opentelemetry.util import types

_KEY_FORMAT = ...
_KEY_PATTERN = ...
_VALUE_FORMAT = ...
_VALUE_PATTERN = ...
_TRACECONTEXT_MAXIMUM_TRACESTATE_KEYS = ...
_delimiter_pattern = ...
_member_pattern = ...
_logger = ...

class Span(abc.ABC):
    """A span represents a single operation within a trace."""

    @abc.abstractmethod
    def end(self, end_time: int | None = ...) -> None:
        """Sets the current time as the span's end time.

        The span's end time is the wall time at which the operation finished.

        Only the first call to `end` should modify the span, and
        implementations are free to ignore or raise on further calls.
        """
        ...

    @abc.abstractmethod
    def get_span_context(self) -> SpanContext:
        """Gets the span's SpanContext.

        Get an immutable, serializable identifier for this span that can be
        used to create new child spans.

        Returns:
            A :class:`opentelemetry.trace.SpanContext` with a copy of this span's immutable state.

        """
        ...

    @abc.abstractmethod
    def set_attributes(self, attributes: dict[str, types.AttributeValue]) -> None:
        """Sets Attributes.

        Sets Attributes with the key and value passed as arguments dict.

        Note: The behavior of `None` value attributes is undefined, and hence
        strongly discouraged. It is also preferred to set attributes at span
        creation, instead of calling this method later since samplers can only
        consider information already present during span creation.
        """
        ...

    @abc.abstractmethod
    def set_attribute(self, key: str, value: types.AttributeValue) -> None:
        """Sets an Attribute.

        Sets a single Attribute with the key and value passed as arguments.

        Note: The behavior of `None` value attributes is undefined, and hence
        strongly discouraged. It is also preferred to set attributes at span
        creation, instead of calling this method later since samplers can only
        consider information already present during span creation.
        """
        ...

    @abc.abstractmethod
    def add_event(self, name: str, attributes: types.Attributes = ..., timestamp: int | None = ...) -> None:
        """Adds an `Event`.

        Adds a single `Event` with the name and, optionally, a timestamp and
        attributes passed as arguments. Implementations should generate a
        timestamp if the `timestamp` argument is omitted.
        """
        ...

    def add_link(self, context: SpanContext, attributes: types.Attributes = ...) -> None:
        """Adds a `Link`.

        Adds a single `Link` with the `SpanContext` of the span to link to and,
        optionally, attributes passed as arguments. Implementations may ignore
        calls with an invalid span context if both attributes and TraceState
        are empty.

        Note: It is preferred to add links at span creation, instead of calling
        this method later since samplers can only consider information already
        present during span creation.
        """

    @abc.abstractmethod
    def update_name(self, name: str) -> None:
        """Updates the `Span` name.

        This will override the name provided via :func:`opentelemetry.trace.Tracer.start_span`.

        Upon this update, any sampling behavior based on Span name will depend
        on the implementation.
        """
        ...

    @abc.abstractmethod
    def is_recording(self) -> bool:
        """Returns whether this span will be recorded.

        Returns true if this Span is active and recording information like
        events with the add_event operation and attributes using set_attribute.
        """
        ...

    @abc.abstractmethod
    def set_status(self, status: Status | StatusCode, description: str | None = ...) -> None:
        """Sets the Status of the Span. If used, this will override the default
        Span status.
        """
        ...

    @abc.abstractmethod
    def record_exception(
        self,
        exception: BaseException,
        attributes: types.Attributes = ...,
        timestamp: int | None = ...,
        escaped: bool = ...,
    ) -> None:
        """Records an exception as a span event."""
        ...

    def __enter__(self) -> Span:
        """Invoked when `Span` is used as a context manager.

        Returns the `Span` itself.
        """

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_val: BaseException | None,
        exc_tb: python_types.TracebackType | None,
    ) -> None:
        """Ends context manager and calls `end` on the `Span`."""

class TraceFlags(int):
    """A bitmask that represents options specific to the trace.

    The only supported option is the "sampled" flag (``0x01``). If set, this
    flag indicates that the trace may have been sampled upstream.

    See the `W3C Trace Context - Traceparent`_ spec for details.

    .. _W3C Trace Context - Traceparent:
        https://www.w3.org/TR/trace-context/#trace-flags
    """

    DEFAULT = ...
    SAMPLED = ...
    @classmethod
    def get_default(cls) -> TraceFlags: ...
    @property
    def sampled(self) -> bool: ...

DEFAULT_TRACE_OPTIONS = ...

class TraceState(typing.Mapping[str, str]):
    """A list of key-value pairs representing vendor-specific trace info.

    Keys and values are strings of up to 256 printable US-ASCII characters.
    Implementations should conform to the `W3C Trace Context - Tracestate`_
    spec, which describes additional restrictions on valid field values.

    .. _W3C Trace Context - Tracestate:
        https://www.w3.org/TR/trace-context/#tracestate-field
    """

    def __init__(self, entries: typing.Sequence[tuple[str, str]] | None = ...) -> None: ...
    def __contains__(self, item: object) -> bool: ...
    def __getitem__(self, key: str) -> str: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __len__(self) -> int: ...
    def add(self, key: str, value: str) -> TraceState:
        """Adds a key-value pair to tracestate. The provided pair should
        adhere to w3c tracestate identifiers format.

        Args:
            key: A valid tracestate key to add
            value: A valid tracestate value to add

        Returns:
            A new TraceState with the modifications applied.

            If the provided key-value pair is invalid or results in tracestate
            that violates tracecontext specification, they are discarded and
            same tracestate will be returned.

        """

    def update(self, key: str, value: str) -> TraceState:
        """Updates a key-value pair in tracestate. The provided pair should
        adhere to w3c tracestate identifiers format.

        Args:
            key: A valid tracestate key to update
            value: A valid tracestate value to update for key

        Returns:
            A new TraceState with the modifications applied.

            If the provided key-value pair is invalid or results in tracestate
            that violates tracecontext specification, they are discarded and
            same tracestate will be returned.

        """

    def delete(self, key: str) -> TraceState:
        """Deletes a key-value from tracestate.

        Args:
            key: A valid tracestate key to remove key-value pair from tracestate

        Returns:
            A new TraceState with the modifications applied.

            If the provided key-value pair is invalid or results in tracestate
            that violates tracecontext specification, they are discarded and
            same tracestate will be returned.

        """

    def to_header(self) -> str:
        """Creates a w3c tracestate header from a TraceState.

        Returns:
            A string that adheres to the w3c tracestate
            header format.

        """

    @classmethod
    def from_header(cls, header_list: list[str]) -> TraceState:
        """Parses one or more w3c tracestate header into a TraceState.

        Args:
            header_list: one or more w3c tracestate headers.

        Returns:
            A valid TraceState that contains values extracted from
            the tracestate header.

            If the format of one headers is illegal, all values will
            be discarded and an empty tracestate will be returned.

            If the number of keys is beyond the maximum, all values
            will be discarded and an empty tracestate will be returned.

        """

    @classmethod
    def get_default(cls) -> TraceState: ...
    def keys(self) -> typing.KeysView[str]: ...
    def items(self) -> typing.ItemsView[str, str]: ...
    def values(self) -> typing.ValuesView[str]: ...

DEFAULT_TRACE_STATE = ...
_TRACE_ID_MAX_VALUE = ...
_SPAN_ID_MAX_VALUE = ...

class SpanContext(tuple[int, int, bool, TraceFlags, TraceState, bool]):
    """The state of a Span to propagate between processes.

    This class includes the immutable attributes of a :class:`.Span` that must
    be propagated to a span's children and across process boundaries.

    Args:
        trace_id: The ID of the trace that this span belongs to.
        span_id: This span's ID.
        is_remote: True if propagated from a remote parent.
        trace_flags: Trace options to propagate.
        trace_state: Tracing-system-specific info to propagate.

    """

    def __new__(
        cls,
        trace_id: int,
        span_id: int,
        is_remote: bool,
        trace_flags: TraceFlags | None = ...,
        trace_state: TraceState | None = ...,
    ) -> SpanContext: ...
    def __getnewargs__(self) -> tuple[int, int, bool, TraceFlags, TraceState]: ...
    @property
    def trace_id(self) -> int: ...
    @property
    def span_id(self) -> int: ...
    @property
    def is_remote(self) -> bool: ...
    @property
    def trace_flags(self) -> TraceFlags: ...
    @property
    def trace_state(self) -> TraceState: ...
    @property
    def is_valid(self) -> bool: ...
    def __setattr__(self, *args: str) -> None: ...
    def __delattr__(self, *args: str) -> None: ...

class NonRecordingSpan(Span):
    """The Span that is used when no Span implementation is available.

    All operations are no-op except context propagation.
    """

    def __init__(self, context: SpanContext) -> None: ...
    def get_span_context(self) -> SpanContext: ...
    def is_recording(self) -> bool: ...
    def end(self, end_time: int | None = ...) -> None: ...
    def set_attributes(self, attributes: dict[str, types.AttributeValue]) -> None: ...
    def set_attribute(self, key: str, value: types.AttributeValue) -> None: ...
    def add_event(self, name: str, attributes: types.Attributes = ..., timestamp: int | None = ...) -> None: ...
    def add_link(self, context: SpanContext, attributes: types.Attributes = ...) -> None: ...
    def update_name(self, name: str) -> None: ...
    def set_status(self, status: Status | StatusCode, description: str | None = ...) -> None: ...
    def record_exception(
        self,
        exception: BaseException,
        attributes: types.Attributes = ...,
        timestamp: int | None = ...,
        escaped: bool = ...,
    ) -> None: ...

INVALID_SPAN_ID = ...
INVALID_TRACE_ID = ...
INVALID_SPAN_CONTEXT = ...
INVALID_SPAN = ...

def format_trace_id(trace_id: int) -> str:
    """Convenience trace ID formatting method
    Args:
        trace_id: Trace ID int

    Returns:
        The trace ID as 32-byte hexadecimal string

    """

def format_span_id(span_id: int) -> str:
    """Convenience span ID formatting method
    Args:
        span_id: Span ID int

    Returns:
        The span ID as 16-byte hexadecimal string

    """
