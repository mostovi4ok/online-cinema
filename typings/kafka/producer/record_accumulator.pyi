"""
This type stub file was generated by pyright.
"""

log = ...

class AtomicInteger:
    def __init__(self, val=...) -> None: ...
    def increment(self):  # -> int:
        ...
    def decrement(self):  # -> int:
        ...
    def get(self):  # -> int:
        ...

class ProducerBatch:
    def __init__(self, tp, records, buffer) -> None: ...
    @property
    def record_count(self): ...
    def try_append(self, timestamp_ms, key, value, headers):  # -> FutureRecordMetadata | None:
        ...
    def done(
        self, base_offset=..., timestamp_ms=..., exception=..., log_start_offset=..., global_error=...
    ):  # -> None:
        ...
    def maybe_expire(self, request_timeout_ms, retry_backoff_ms, linger_ms, is_full):  # -> bool:
        """Expire batches if metadata is not available

        A batch whose metadata is not available should be expired if one
        of the following is true:

          * the batch is not in retry AND request timeout has elapsed after
            it is ready (full or linger.ms has reached).

          * the batch is in retry AND request timeout has elapsed after the
            backoff period ended.
        """

    def in_retry(self):  # -> bool:
        ...
    def set_retry(self):  # -> None:
        ...
    def buffer(self):  # -> Any:
        ...

class RecordAccumulator:
    """
    This class maintains a dequeue per TopicPartition that accumulates messages
    into MessageSets to be sent to the server.

    The accumulator attempts to bound memory use, and append calls will block
    when that memory is exhausted.

    Keyword Arguments:
        batch_size (int): Requests sent to brokers will contain multiple
            batches, one for each partition with data available to be sent.
            A small batch size will make batching less common and may reduce
            throughput (a batch size of zero will disable batching entirely).
            Default: 16384
        buffer_memory (int): The total bytes of memory the producer should use
            to buffer records waiting to be sent to the server. If records are
            sent faster than they can be delivered to the server the producer
            will block up to max_block_ms, raising an exception on timeout.
            In the current implementation, this setting is an approximation.
            Default: 33554432 (32MB)
        compression_attrs (int): The compression type for all data generated by
            the producer. Valid values are gzip(1), snappy(2), lz4(3), or
            none(0).
            Compression is of full batches of data, so the efficacy of batching
            will also impact the compression ratio (more batching means better
            compression). Default: None.
        linger_ms (int): An artificial delay time to add before declaring a
            messageset (that isn't full) ready for sending. This allows
            time for more records to arrive. Setting a non-zero linger_ms
            will trade off some latency for potentially better throughput
            due to more batching (and hence fewer, larger requests).
            Default: 0
        retry_backoff_ms (int): An artificial delay time to retry the
            produce request upon receiving an error. This avoids exhausting
            all retries in a short period of time. Default: 100

    """

    DEFAULT_CONFIG = ...
    def __init__(self, **configs) -> None: ...
    def append(
        self, tp, timestamp_ms, key, value, headers, max_time_to_block_ms, estimated_size=...
    ):  # -> tuple[Any, Any | Literal[True], Literal[False]] | tuple[FutureRecordMetadata, bool, Literal[True]]:
        """Add a record to the accumulator, return the append result.

        The append result will contain the future metadata, and flag for
        whether the appended batch is full or a new batch is created

        Arguments:
            tp (TopicPartition): The topic/partition to which this record is
                being sent
            timestamp_ms (int): The timestamp of the record (epoch ms)
            key (bytes): The key for the record
            value (bytes): The value for the record
            headers (List[Tuple[str, bytes]]): The header fields for the record
            max_time_to_block_ms (int): The maximum time in milliseconds to
                block for buffer memory to be available

        Returns:
            tuple: (future, batch_is_full, new_batch_created)

        """

    def abort_expired_batches(self, request_timeout_ms, cluster):  # -> list[Any]:
        """Abort the batches that have been sitting in RecordAccumulator for
        more than the configured request_timeout due to metadata being
        unavailable.

        Arguments:
            request_timeout_ms (int): milliseconds to timeout
            cluster (ClusterMetadata): current metadata for kafka cluster

        Returns:
            list of ProducerBatch that were expired

        """

    def reenqueue(self, batch):  # -> None:
        """Re-enqueue the given record batch in the accumulator to retry."""

    def ready(self, cluster):  # -> tuple[set[Any], float, bool]:
        """
        Get a list of nodes whose partitions are ready to be sent, and the
        earliest time at which any non-sendable partition will be ready;
        Also return the flag for whether there are any unknown leaders for the
        accumulated partition batches.

        A destination node is ready to send if:

         * There is at least one partition that is not backing off its send
         * and those partitions are not muted (to prevent reordering if
           max_in_flight_requests_per_connection is set to 1)
         * and any of the following are true:

           * The record set is full
           * The record set has sat in the accumulator for at least linger_ms
             milliseconds
           * The accumulator is out of memory and threads are blocking waiting
             for data (in this case all partitions are immediately considered
             ready).
           * The accumulator has been closed

        Arguments:
            cluster (ClusterMetadata):

        Returns:
            tuple:
                ready_nodes (set): node_ids that have ready batches
                next_ready_check (float): secs until next ready after backoff
                unknown_leaders_exist (bool): True if metadata refresh needed

        """

    def has_unsent(self):  # -> bool:
        """Return whether there is any unsent record in the accumulator."""

    def drain(self, cluster, nodes, max_size):  # -> dict[Any, Any]:
        """
        Drain all the data for the given nodes and collate them into a list of
        batches that will fit within the specified size on a per-node basis.
        This method attempts to avoid choosing the same topic-node repeatedly.

        Arguments:
            cluster (ClusterMetadata): The current cluster metadata
            nodes (list): list of node_ids to drain
            max_size (int): maximum number of bytes to drain

        Returns:
            dict: {node_id: list of ProducerBatch} with total size less than the
                requested max_size.

        """

    def deallocate(self, batch):  # -> None:
        """Deallocate the record batch."""

    def begin_flush(self):  # -> None:
        """
        Initiate the flushing of data from the accumulator...this makes all
        requests immediately ready
        """

    def await_flush_completion(self, timeout=...):  # -> None:
        """
        Mark all partitions as ready to send and block until the send is complete
        """

    def abort_incomplete_batches(self):  # -> None:
        """
        This function is only called when sender is closed forcefully. It will fail all the
        incomplete batches and return.
        """

    def close(self):  # -> None:
        """Close this accumulator and force all the record buffers to be drained."""

class IncompleteProducerBatches:
    """A threadsafe helper class to hold ProducerBatches that haven't been ack'd yet"""

    def __init__(self) -> None: ...
    def add(self, batch):  # -> None:
        ...
    def remove(self, batch):  # -> None:
        ...
    def all(self):  # -> list[Any]:
        ...
