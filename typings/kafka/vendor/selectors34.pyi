"""
This type stub file was generated by pyright.
"""

import select
import sys
from abc import ABCMeta, abstractmethod
from collections.abc import Mapping

from kafka.vendor import six

"""Selectors module.

This module allows high-level and efficient I/O multiplexing, built upon the
`select` module primitives.

The following code adapted from trollius.selectors.
"""
EVENT_READ = ...
EVENT_WRITE = ...
SelectorKey = ...

class _SelectorMapping(Mapping):
    """Mapping of file objects to selector keys."""

    def __init__(self, selector) -> None: ...
    def __len__(self):  # -> int:
        ...
    def __getitem__(self, fileobj): ...
    def __iter__(self): ...

@six.add_metaclass(ABCMeta)
class BaseSelector:
    """Selector abstract base class.

    A selector supports registering file objects to be monitored for specific
    I/O events.

    A file object is a file descriptor or any object with a `fileno()` method.
    An arbitrary object can be attached to the file object, which can be used
    for example to store context information, a callback, etc.

    A selector can use various implementations (select(), poll(), epoll()...)
    depending on the platform. The default `Selector` class uses the most
    efficient implementation on the current platform.
    """

    @abstractmethod
    def register(self, fileobj, events, data=...):
        """Register a file object.

        Parameters
        ----------
        fileobj -- file object or file descriptor
        events  -- events to monitor (bitwise mask of EVENT_READ|EVENT_WRITE)
        data    -- attached data

        Returns
        -------
        SelectorKey instance

        Raises
        ------
        ValueError if events is invalid
        KeyError if fileobj is already registered
        OSError if fileobj is closed or otherwise is unacceptable to
                the underlying system call (if a system call is made)

        Note:
        OSError may or may not be raised

        """
        ...

    @abstractmethod
    def unregister(self, fileobj):
        """Unregister a file object.

        Parameters
        ----------
        fileobj -- file object or file descriptor

        Returns
        -------
        SelectorKey instance

        Raises
        ------
        KeyError if fileobj is not registered

        Note:
        If fileobj is registered but has since been closed this does
        *not* raise OSError (even if the wrapped syscall does)

        """
        ...

    def modify(self, fileobj, events, data=...):
        """Change a registered file object monitored events or attached data.

        Parameters
        ----------
        fileobj -- file object or file descriptor
        events  -- events to monitor (bitwise mask of EVENT_READ|EVENT_WRITE)
        data    -- attached data

        Returns
        -------
        SelectorKey instance

        Raises
        ------
        Anything that unregister() or register() raises

        """

    @abstractmethod
    def select(self, timeout=...):
        """Perform the actual selection, until some monitored file objects are
        ready or a timeout expires.

        Parameters
        ----------
        timeout -- if timeout > 0, this specifies the maximum wait time, in
                   seconds
                   if timeout <= 0, the select() call won't block, and will
                   report the currently ready file objects
                   if timeout is None, select() will block until a monitored
                   file object becomes ready

        Returns
        -------
        list of (key, events) for ready file objects
        `events` is a bitwise mask of EVENT_READ|EVENT_WRITE

        """
        ...

    def close(self):  # -> None:
        """Close the selector.

        This must be called to make sure that any underlying resource is freed.
        """

    def get_key(self, fileobj):
        """Return the key associated to a registered file object.

        Returns:
        SelectorKey for this file object

        """

    @abstractmethod
    def get_map(self):
        """Return a mapping of file objects to selector keys."""
        ...

    def __enter__(self):  # -> Self:
        ...
    def __exit__(self, *args):  # -> None:
        ...

class _BaseSelectorImpl(BaseSelector):
    """Base selector implementation."""

    def __init__(self) -> None: ...
    def register(self, fileobj, events, data=...):  # -> SelectorKey:
        ...
    def unregister(self, fileobj): ...
    def modify(self, fileobj, events, data=...):  # -> SelectorKey:
        ...
    def close(self):  # -> None:
        ...
    def get_map(self):  # -> _SelectorMapping | None:
        ...

class SelectSelector(_BaseSelectorImpl):
    """Select-based selector."""

    def __init__(self) -> None: ...
    def register(self, fileobj, events, data=...):  # -> SelectorKey:
        ...
    def unregister(self, fileobj): ...

    if sys.platform == "win32": ...
    else:
        _select = ...
    def select(self, timeout=...):  # -> list[Any]:
        ...

if hasattr(select, "poll"):
    class PollSelector(_BaseSelectorImpl):
        """Poll-based selector."""

        def __init__(self) -> None: ...
        def register(self, fileobj, events, data=...):  # -> SelectorKey:
            ...
        def unregister(self, fileobj): ...
        def select(self, timeout=...):  # -> list[Any]:
            ...

if hasattr(select, "epoll"):
    class EpollSelector(_BaseSelectorImpl):
        """Epoll-based selector."""

        def __init__(self) -> None: ...
        def fileno(self):  # -> int:
            ...
        def register(self, fileobj, events, data=...):  # -> SelectorKey:
            ...
        def unregister(self, fileobj): ...
        def select(self, timeout=...):  # -> list[Any]:
            ...
        def close(self):  # -> None:
            ...

if hasattr(select, "devpoll"):
    class DevpollSelector(_BaseSelectorImpl):
        """Solaris /dev/poll selector."""

        def __init__(self) -> None: ...
        def fileno(self): ...
        def register(self, fileobj, events, data=...):  # -> SelectorKey:
            ...
        def unregister(self, fileobj): ...
        def select(self, timeout=...):  # -> list[Any]:
            ...
        def close(self):  # -> None:
            ...

if hasattr(select, "kqueue"):
    class KqueueSelector(_BaseSelectorImpl):
        """Kqueue-based selector."""

        def __init__(self) -> None: ...
        def fileno(self): ...
        def register(self, fileobj, events, data=...):  # -> SelectorKey:
            ...
        def unregister(self, fileobj): ...
        def select(self, timeout=...):  # -> list[Any]:
            ...
        def close(self):  # -> None:
            ...

if "KqueueSelector" in globals():
    DefaultSelector = ...
else:
    DefaultSelector = ...
