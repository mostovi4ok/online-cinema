"""
This type stub file was generated by pyright.
"""

"""Python Enumerations"""
__all__ = ["Enum", "IntEnum", "unique"]
version = ...
pyver = ...

class _RouteClassAttributeToGetattr:
    """Route attribute access on a class to __getattr__.

    This is a descriptor, used to define attributes that act differently when
    accessed through an instance and through a class.  Instance access remains
    normal, but access to an attribute through a class will be routed to the
    class's __getattr__ method; this is done by raising AttributeError.

    """

    def __init__(self, fget=...) -> None: ...
    def __get__(self, instance, ownerclass=...): ...
    def __set__(self, instance, value): ...
    def __delete__(self, instance): ...

class _EnumDict(dict):
    """Track enum member order and ensure member names are not reused.

    EnumMeta will use the names found in self._member_names as the
    enumeration member names.

    """

    def __init__(self) -> None: ...
    def __setitem__(self, key, value):  # -> None:
        """Changes anything not dundered or not a descriptor.

        If a descriptor is added with the same name as an enum member, the name
        is removed from _member_names (this may leave a hole in the numerical
        sequence of values).

        If an enum member name is used twice, an error is raised; duplicate
        values are not checked for.

        Single underscore (sunder) names are reserved.

        Note:   in 3.x __order__ is simply discarded as a not necessary piece
                leftover from 2.x

        """

Enum = ...

class EnumMeta(type):
    """Metaclass for Enum"""

    @classmethod
    def __prepare__(metacls, cls, bases):  # -> _EnumDict:
        ...
    def __new__(metacls, cls, bases, classdict): ...
    def __bool__(cls):  # -> Literal[True]:
        """
        classes/types should always be True.
        """

    def __call__(cls, value, names=..., module=..., type=..., start=...):
        """Either returns an existing member, or creates a new enum class.

        This method is used both when an enum class is given a value to match
        to an enumeration member (i.e. Color(3)) and for the functional API
        (i.e. Color = Enum('Color', names='red green blue')).

        When used for the functional API: `module`, if set, will be stored in
        the new class' __module__ attribute; `type`, if set, will be mixed in
        as the first base class.

        Note: if `module` is not set this routine will attempt to discover the
        calling module by walking the frame stack; if this is unsuccessful
        the resulting class will not be pickleable.

        """

    def __contains__(cls, member):  # -> bool:
        ...
    def __delattr__(cls, attr):  # -> None:
        ...
    def __dir__(self): ...
    @property
    def __members__(cls):
        """Returns a mapping of member name->value.

        This mapping lists all enum members, including aliases. Note that this
        is a copy of the internal mapping.

        """

    def __getattr__(cls, name):
        """Return the enum member matching `name`

        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.

        """

    def __getitem__(cls, name): ...
    def __iter__(cls):  # -> Generator[Any, None, None]:
        ...
    def __reversed__(cls):  # -> Generator[Any, None, None]:
        ...
    def __len__(cls):  # -> int:
        ...

    __nonzero__ = ...
    def __repr__(cls):  # -> str:
        ...
    def __setattr__(cls, name, value):  # -> None:
        """Block attempts to reassign Enum members.

        A simple assignment to the class namespace only changes one of the
        several possible ways to get an Enum member from the Enum class,
        resulting in an inconsistent Enumeration.

        """

    if pyver < 3: ...
    else: ...

temp_enum_dict = ...

def __new__(cls, value): ...
def __repr__(self):  # -> LiteralString:
    ...
def __str__(self) -> str: ...

if pyver >= 3:
    def __dir__(self):  # -> list[str]:
        ...

def __format__(self, format_spec):  # -> str:
    ...

if pyver < 2.6:
    def __cmp__(self, other):  # -> _NotImplementedType | Literal[0, -1]:
        ...

else:
    def __le__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...

def __eq__(self, other) -> bool: ...
def __ne__(self, other) -> bool: ...
def __hash__(self) -> int: ...
def __reduce_ex__(self, proto):  # -> tuple[Any, tuple[Any]]:
    ...
@_RouteClassAttributeToGetattr
def name(self): ...
@_RouteClassAttributeToGetattr
def value(self): ...

Enum = ...

class IntEnum(int, Enum):
    """Enum where members are also (and must be) ints"""

def unique(enumeration):
    """Class decorator that ensures only unique members exist in an enumeration."""
